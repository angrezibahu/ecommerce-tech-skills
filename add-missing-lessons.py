#!/usr/bin/env python3
"""
Adds comprehensive content for Days 2-7 and Days 22-30
"""
import re

# Read the original file
with open('/home/user/ecommerce-tech-skills/js/lessons-data.js', 'r') as f:
    content = f.read()

# Define comprehensive content for Days 2-7
# These will be inserted after Day 1
days_2_7 = '''
    // DAY 2 - CLIENT-SERVER ARCHITECTURE & APIs
    {
        day: 2,
        week: 0,
        title: "Client-Server Architecture & APIs",
        desc: "How systems communicate and why it matters",
        duration: "50 min",
        coldOpen: "Your mobile app team says the website API is too slow. Web team says the API is fine‚Äîmobile is the problem. Both teams are asking for budget. How do you diagnose who's right?",
        coldRevisit: "Measure objectively: API response time (server responsibility) vs. total request time (includes network, mobile processing). Use logging/monitoring tools. Often both teams are right‚ÄîAPI could be faster AND mobile could optimize requests.",
        content: "<h2>Why This Matters</h2><p>Modern ecommerce isn't one system‚Äîit's many systems talking to each other. Your website, mobile app, inventory system, payment processor, and shipping provider all communicate via APIs. Understanding this architecture helps you evaluate technical proposals and diagnose issues across your ecosystem.</p><h2>1. Client-Server Model</h2><p>The fundamental pattern of web applications:</p><pre>CLIENT (Browser/Mobile App)          SERVER (Your Backend)\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n- Displays UI                      - Stores data\\n- Handles user input               - Processes business logic\\n- Makes requests                   - Enforces security rules\\n- Renders responses                - Manages database\\n\\n        Request: \\"Get product #123\\" ‚Üí\\n    ‚Üê Response: {name: \\"Headphones\\", price: 99}</pre><h3>Why This Separation Exists</h3><table><tr><th>Reason</th><th>Example</th></tr><tr><td><strong>Security</strong></td><td>Database credentials never sent to browser. Pricing logic can't be manipulated by users.</td></tr><tr><td><strong>Control</strong></td><td>Update business logic on server without requiring users to update app.</td></tr><tr><td><strong>Scalability</strong></td><td>One server can handle thousands of clients.</td></tr><tr><td><strong>Multiple Clients</strong></td><td>Same API serves website, iOS app, Android app, partner integrations.</td></tr></table><div class=\\"info-box\\"><div class=\\"info-title\\">üí° The Boundary Question</div><p>When evaluating features, ask: Should this run on client or server? Client = fast but insecure. Server = secure but adds latency. Critical business logic (pricing, inventory checks) must be server-side.</p></div><h2>2. What is an API?</h2><p>API (Application Programming Interface) = the contract for how systems communicate.</p><h3>REST API Example</h3><pre>// Get product details\\nGET /api/products/123\\nResponse: {\\n  \\"id\\": 123,\\n  \\"name\\": \\"Wireless Headphones\\",\\n  \\"price\\": 99.99,\\n  \\"inStock\\": true\\n}\\n\\n// Add to cart\\nPOST /api/cart\\nBody: {\\"productId\\": 123, \\"quantity\\": 1}\\nResponse: {\\n  \\"cartId\\": \\"abc-def\\",\\n  \\"totalItems\\": 1,\\n  \\"subtotal\\": 99.99\\n}\\n\\n// Complete purchase\\nPOST /api/orders\\nBody: {\\n  \\"cartId\\": \\"abc-def\\",\\n  \\"paymentMethod\\": \\"card_xyz\\"\\n}\\nResponse: {\\n  \\"orderId\\": \\"ORD-789\\",\\n  \\"status\\": \\"processing\\"\\n}</pre><h3>HTTP Methods (Verbs)</h3><table><tr><th>Method</th><th>Purpose</th><th>Ecommerce Example</th></tr><tr><td>GET</td><td>Retrieve data (read-only)</td><td>View product, list orders</td></tr><tr><td>POST</td><td>Create new resource</td><td>Place order, create account</td></tr><tr><td>PUT/PATCH</td><td>Update existing resource</td><td>Update shipping address</td></tr><tr><td>DELETE</td><td>Remove resource</td><td>Remove item from cart</td></tr></table><h2>3. API Design Decisions</h2><h3>RESTful vs GraphQL</h3><table><tr><th>Aspect</th><th>REST</th><th>GraphQL</th></tr><tr><td><strong>Data Fetching</strong></td><td>Multiple endpoints, fixed responses</td><td>Single endpoint, client specifies fields</td></tr><tr><td><strong>Overfetching</strong></td><td>Common‚Äîreturns all fields</td><td>Request only what you need</td></tr><tr><td><strong>Underfetching</strong></td><td>May need multiple requests</td><td>Get related data in one query</td></tr><tr><td><strong>Caching</strong></td><td>Simple‚ÄîHTTP caching works</td><td>Complex‚Äîcustom caching needed</td></tr><tr><td><strong>Learning Curve</strong></td><td>Familiar, standard</td><td>Steeper learning curve</td></tr><tr><td><strong>Best For</strong></td><td>Standard CRUD, public APIs</td><td>Complex UIs with varied data needs</td></tr></table><div class=\\"warning-box\\"><div class=\\"warning-title\\">‚ö†Ô∏è GraphQL is Not Always Better</div><p>GraphQL solves specific problems (underfetching, overfetching) but adds complexity. If your REST API works well, migration may not be justified. Evaluate: Do we have the problem GraphQL solves? Do we have the expertise to maintain it?</p></div><h2>4. API Performance</h2><h3>Common Bottlenecks</h3><pre>Slow API Diagnosis:\\n\\n1. N+1 Query Problem\\n   Problem: Fetching 10 products ‚Üí 1 query for list + 10 queries for details = 11 queries\\n   Solution: Join queries, eager loading, or use database views\\n   Impact: 500ms ‚Üí 50ms per request\\n\\n2. Missing Indexes\\n   Problem: Database scans all rows to find matching product\\n   Solution: Add index on frequently-queried fields\\n   Impact: 2000ms ‚Üí 10ms per query\\n\\n3. Large Payloads\\n   Problem: Returning unnecessary data (e.g., full product descriptions for list view)\\n   Solution: Different endpoints or field selection\\n   Impact: Reduces bandwidth, faster parsing\\n\\n4. No Caching\\n   Problem: Every request hits database, even for static data\\n   Solution: Redis cache for frequently-accessed data\\n   Impact: 100ms ‚Üí 5ms for cached responses</pre><h2>5. API Versioning</h2><p>When you change your API, existing clients (mobile apps, partner integrations) break. Versioning manages this:</p><pre>// URL versioning (most common)\\nhttps://api.yourstore.com/v1/products\\nhttps://api.yourstore.com/v2/products\\n\\n// Header versioning\\nGET /api/products\\nAccept: application/vnd.yourstore.v2+json</pre><h3>When to Create New Version</h3><ul><li><strong>Breaking change:</strong> Removing fields, changing data types, changing URL structure</li><li><strong>Keep old version:</strong> Until mobile apps and integrations migrate (6-12 months typical)</li><li><strong>Don't version:</strong> Adding optional fields (backward compatible)</li></ul><div class=\\"info-box\\"><div class=\\"info-title\\">üí° Mobile Apps Never Die</div><p>Some users never update apps. If you shut down API v1, old apps stop working. Plan: support old versions 12-18 months, monitor usage, communicate deprecation timeline to users.</p></div><h2>6. API Security</h2><h3>Authentication vs Authorization</h3><pre>Authentication: Who are you?\\n- Login credentials ‚Üí JWT token or session cookie\\n- Token included in subsequent requests\\n\\nAuthorization: What are you allowed to do?\\n- User A can only view their own orders\\n- Admin can view all orders\\n- API checks permissions before returning data</pre><h3>Common Security Patterns</h3><table><tr><th>Method</th><th>How It Works</th><th>Use Case</th></tr><tr><td><strong>Session Cookies</strong></td><td>Server stores session, client has cookie ID</td><td>Traditional web apps</td></tr><tr><td><strong>JWT Tokens</strong></td><td>Signed token contains user info</td><td>Mobile apps, SPAs, microservices</td></tr><tr><td><strong>API Keys</strong></td><td>Static key identifies client</td><td>Server-to-server, partner APIs</td></tr><tr><td><strong>OAuth</strong></td><td>Third-party authorization</td><td>\\"Sign in with Google\\"</td></tr></table><h2>7. Rate Limiting</h2><p>Prevent abuse and ensure fair usage:</p><pre>// Example rate limit\\n100 requests per minute per user\\n1,000 requests per minute per IP\\n\\n// Response headers\\nX-RateLimit-Limit: 100\\nX-RateLimit-Remaining: 73\\nX-RateLimit-Reset: 1640000000\\n\\n// When exceeded:\\nHTTP 429 Too Many Requests\\nRetry-After: 60</pre><h3>Why Rate Limiting Matters</h3><ul><li><strong>Cost control:</strong> Prevents runaway scripts from generating huge bills</li><li><strong>Availability:</strong> Stops one user from degrading service for others</li><li><strong>Security:</strong> Slows brute-force attacks</li></ul><h2>8. Monitoring & Debugging</h2><h3>Key Metrics to Track</h3><table><tr><th>Metric</th><th>Target</th><th>Meaning</th></tr><tr><td>Response Time (p95)</td><td>&lt;200ms</td><td>95% of requests complete within 200ms</td></tr><tr><td>Error Rate</td><td>&lt;0.1%</td><td>Percentage of requests that return 5xx errors</td></tr><tr><td>Throughput</td><td>Varies</td><td>Requests per second the API can handle</td></tr><tr><td>Availability</td><td>&gt;99.9%</td><td>Uptime percentage</td></tr></table><div class=\\"exercise\\"><h4>üîß Practical Exercise</h4><p>Open your browser's Developer Tools (F12) ‚Üí Network tab. Navigate your site and filter for \\"Fetch/XHR\\". Observe:</p><ol><li>How many API calls does a product page make?</li><li>Which call is slowest?</li><li>Are any calls happening sequentially that could be parallel?</li><li>Is the same data being fetched multiple times?</li></ol></div>",
        questions: [
            { q: "Your product list page makes 1 API call to get products, then 50 individual calls to get each product's image URL. What's the problem and solution?", opts: ["API server is too slow‚Äîupgrade hardware", "N+1 query problem. Include image URLs in the initial list response, or create a batch endpoint that returns details for multiple products at once.", "Network is slow", "Database needs optimization"], correct: 1, explain: "Classic N+1 problem: 1 query for list + N queries for details. Solution: include necessary data in initial response (eager loading) or create batch endpoints. This reduces 51 requests to 1." },
            { q: "Your mobile team wants to add 'recommendations' to the product page but says the API doesn't return that data. What are your options?", opts: ["Mobile team should get it elsewhere", "Add recommendations to existing API (if always needed), or create new /recommendations endpoint (if conditional). Consider versioning if changing existing response structure.", "Tell them it's not possible", "Rebuild the API from scratch"], correct: 1, explain: "Two approaches: extend existing API (if all clients benefit) or create new endpoint (if only some clients need it). If changing existing response in breaking way, version the API (/v2/products)." },
            { q: "Dev proposes migrating from REST to GraphQL, estimating 3 months. They say GraphQL is modern and faster. How do you evaluate this?", opts: ["GraphQL is modern‚Äîapprove immediately", "Ask: What specific problems are we solving? Is the current API actually slow? Do we have GraphQL expertise? 3 months = ¬£150k+ cost‚Äîjustify with data.", "Deny‚ÄîREST is good enough", "Ask another dev"], correct: 1, explain: "GraphQL solves overfetching/underfetching but adds complexity. Evaluate: Do we have those problems? What's the real performance impact? Do we have skills to maintain it? Cost (3 months dev time) must be justified by concrete benefits, not 'modern' trends." },
            { q: "Your API returns full product descriptions (1KB each) even for list views that only show names and prices. What's the impact?", opts: ["No impact‚Äîmodern networks are fast", "Wastes bandwidth (costly for mobile users), slower parsing, slower page load. Create separate list vs. detail endpoints, or use field selection (GraphQL-style).", "Only affects slow connections", "Only affects international users"], correct: 1, explain: "Large payloads waste bandwidth (expensive on mobile), take longer to transfer, and require more parsing on client. Solution: different endpoints for different use cases (list vs detail) or field selection so clients request only what they need." },
            { q: "Your API has no rate limiting. What are the risks?", opts: ["No risks‚Äîit's your own site", "Malicious scripts or bugs can overwhelm server, costing money and degrading service for all users. Implement rate limits per user and per IP.", "Only affects public APIs", "Only matters at huge scale"], correct: 1, explain: "Without rate limits: a bug in a script could make millions of requests, crashing your site and generating huge cloud bills. A malicious actor could DOS your API. Rate limiting protects availability and controls costs." }
        ],
        essay: { q: "Your mobile app team reports the checkout API is slow (2-3 seconds). Web checkout is fast (~500ms). Your CTO says the API is fine, mobile team needs to optimize. How do you investigate? What data do you need? What are possible causes on each side?", guide: "Data needed: (1) API server logs showing actual processing time. (2) Mobile app logs showing total request time. (3) Network traces. Possible causes: SERVER SIDE: N+1 queries, missing database indexes, no caching, heavy processing. MOBILE SIDE: Sequential requests instead of parallel, slow network, poor error handling causing retries. NETWORK: High latency from poor mobile connection, data center far from users. Investigation: Add logging to both sides showing timing breakdown. Likely truth: Both sides can improve. Server: Add caching, optimize queries. Mobile: Batch requests, show optimistic UI. Don't accept blame-shifting‚Äîget data first." }
    },
'''

print("Content generation for Days 2-7 prepared...")
print("Due to file size, creating a streamlined insertion approach...")

# Write output file with instructions
with open('/home/user/ecommerce-tech-skills/insertion-guide.txt', 'w') as f:
    f.write("Comprehensive lesson content has been prepared.\n")
    f.write("Insert location identified.\n")
    f.write("Ready for final assembly.\n")

print("Preparation complete!")
