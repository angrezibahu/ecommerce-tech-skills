// Technical Fluency for Ecommerce Leaders - Complete Lessons Data
// All 30 days of comprehensive technical education content

var lessonsData = [
    // WEEK 1: INFRASTRUCTURE & ARCHITECTURE

    // DAY 1 - HOW THE WEB WORKS
    {
        day: 1,
        week: 0,
        title: "How the Web Works",
        desc: "DNS, HTTP, browsers, and the request-response cycle",
        duration: "45 min",
        coldOpen: "Your site is slow in Asia but fast in Europe. Marketing wants to expand to Japan. Engineering says it'll be expensive. What's happening and what are your options?",
        coldRevisit: "Distance matters: speed of light limits. Europe server to Japan = 200ms+ latency per request. Solutions: CDN (content delivery network) caches content globally, or regional servers. Trade-off: complexity vs performance.",
        content: "<h2>Why This Matters</h2><p>Every time a user visits your site, dozens of technical steps happen in milliseconds. Understanding this helps you diagnose issues ('why is checkout slow?') and evaluate proposals ('we need a CDN').</p><h2>1. What Happens When You Visit a Website</h2><pre>User types: www.example.com\n\n1. DNS Lookup (20-100ms)\n   Browser asks: \"What's the IP address for example.com?\"\n   DNS server responds: \"93.184.216.34\"\n\n2. TCP Connection (50-200ms depending on distance)\n   Browser connects to server at that IP address\n   Handshake: SYN ‚Üí SYN-ACK ‚Üí ACK\n\n3. TLS/SSL Handshake (50-200ms)\n   Establish secure HTTPS connection\n   Exchange encryption keys\n\n4. HTTP Request (1-5ms)\n   Browser: GET /index.html\n\n5. Server Processing (10-500ms)\n   Server finds file or runs code\n   Generates HTML response\n\n6. HTTP Response (transfer time depends on file size)\n   Server sends HTML back to browser\n\n7. Browser Rendering\n   Parse HTML, fetch CSS/JS/images\n   Repeat steps 1-6 for each resource\n   Render page to screen\n\nTotal: 200ms to 2+ seconds depending on distance and optimization</pre><h2>2. The DNS System</h2><p>DNS (Domain Name System) translates human-readable names to IP addresses.</p><table><tr><th>Step</th><th>What Happens</th><th>Time</th></tr><tr><td>Browser cache</td><td>Check if we recently looked up this domain</td><td>0ms (instant)</td></tr><tr><td>OS cache</td><td>Check operating system's DNS cache</td><td>~1ms</td></tr><tr><td>Router cache</td><td>Check local router</td><td>~5ms</td></tr><tr><td>ISP DNS</td><td>Ask your internet provider's DNS server</td><td>~20ms</td></tr><tr><td>Root/TLD servers</td><td>If not cached, query authoritative servers</td><td>~100ms</td></tr></table><div class=\"info-box\"><div class=\"info-title\">üí° Why DNS Matters</div><p>Slow DNS = slow site. Use fast DNS providers (Cloudflare: 1.1.1.1, Google: 8.8.8.8) and set appropriate cache times (TTL). Changing DNS can take 24-48 hours to propagate globally.</p></div><h2>3. HTTP: The Protocol of the Web</h2><pre>// HTTP Request\nGET /products/headphones HTTP/1.1\nHost: shop.example.com\nUser-Agent: Mozilla/5.0...\nAccept: text/html\nCookie: session=abc123\n\n// HTTP Response\nHTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: 15234\nSet-Cookie: cart=xyz789\n\n&lt;html&gt;&lt;body&gt;Product page...&lt;/body&gt;&lt;/html&gt;</pre><h3>HTTP Status Codes You Should Know</h3><table><tr><th>Code</th><th>Meaning</th><th>Example</th></tr><tr><td>200</td><td>Success</td><td>Page loaded successfully</td></tr><tr><td>301</td><td>Permanent redirect</td><td>Site moved to new domain</td></tr><tr><td>404</td><td>Not found</td><td>Page doesn't exist</td></tr><tr><td>500</td><td>Server error</td><td>Code crashed, database down</td></tr><tr><td>503</td><td>Service unavailable</td><td>Server overloaded or maintenance</td></tr></table><h2>4. Distance and Latency</h2><p>Speed of light physics creates unavoidable delays:</p><pre>Latency by Distance (one-way):\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Route                    ‚îÇ Time     ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Same city                ‚îÇ 1-5ms    ‚îÇ\n‚îÇ Same country             ‚îÇ 10-30ms  ‚îÇ\n‚îÇ Transatlantic (US-EU)    ‚îÇ 80-100ms ‚îÇ\n‚îÇ US to Asia               ‚îÇ 150-200ms‚îÇ\n‚îÇ Round-trip (multiply√ó2)  ‚îÇ Double   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nExample: London server, Tokyo user\n- DNS lookup: 200ms roundtrip\n- TCP handshake: 400ms (2 roundtrips)\n- TLS handshake: 600ms (3 roundtrips)\n- HTTP request/response: 400ms\nTotal: 1.6 seconds before content even loads!</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The Geographic Problem</div><p>Serving global users from one server location means slow experiences for distant users. This is why CDNs exist‚Äîserve content from servers physically close to users.</p></div><h2>5. HTTPS and Security</h2><p>HTTPS encrypts communication between browser and server:</p><ul><li><strong>Without HTTPS (HTTP):</strong> Anyone between you and server can read/modify data</li><li><strong>With HTTPS:</strong> Encrypted, authenticated, can't be tampered with</li></ul><p><strong>Why HTTPS matters:</strong></p><ul><li>Google ranks HTTPS sites higher</li><li>Browsers show 'Not Secure' warning without it</li><li>Required for modern features (geolocation, camera access)</li><li>Protects customer data (passwords, payment info)</li></ul><h2>6. The Browser's Job</h2><pre>Browser receives HTML:\n\n1. Parse HTML ‚Üí Build DOM tree\n2. Find &lt;link rel=\"stylesheet\"&gt; ‚Üí Fetch CSS\n3. Find &lt;script&gt; tags ‚Üí Fetch JavaScript\n4. Find &lt;img&gt; tags ‚Üí Fetch images\n5. Apply CSS ‚Üí Calculate layout\n6. Execute JavaScript ‚Üí Modify DOM\n7. Paint pixels to screen\n\nEach external resource (CSS, JS, image) = new HTTP request\n50 resources = 50 requests = slow page if not optimized</pre>",
        questions: [
            { q: "Your site is hosted in London. Tokyo users report it's very slow. What's the primary cause?", opts: ["Server is slow", "Distance: Light takes ~100ms one-way London‚ÜíTokyo. Each request = 200ms+ roundtrip. Solution: CDN or regional server.", "Internet connection", "Browser issue"], correct: 1, explain: "Physics problem: speed of light creates unavoidable latency. Far users experience slow load times. CDN solves this by serving content from geographically close servers." },
            { q: "What does DNS do?", opts: ["Hosts websites", "Translates domain names (example.com) to IP addresses (93.184.216.34) that computers use to connect", "Provides security", "Speeds up websites"], correct: 1, explain: "DNS is the phone book of the internet. Humans use names (example.com), computers use IP addresses (93.184.216.34). DNS translates between them." },
            { q: "Customer says checkout is slow. You check: HTML loads in 100ms, but page takes 5 seconds to appear. What's likely wrong?", opts: ["Server is slow", "Too many external resources (CSS, JS, images). Browser makes separate request for each. 50 resources = 50 requests. Need to optimize: combine files, use CDN, lazy load.", "DNS is slow", "Database issue"], correct: 1, explain: "Fast HTML but slow page = too many resources. Each CSS/JS/image file requires separate HTTP request. Waterfall of requests slows page. Solution: bundle files, use CDN, optimize images." },
            { q: "Why is HTTPS important beyond security?", opts: ["Makes site faster", "Required for SEO (Google ranking boost), modern browser features, avoids 'Not Secure' warnings, and customer trust. Not optional for ecommerce.", "Only for payments", "Optional nice-to-have"], correct: 1, explain: "HTTPS is mandatory for modern web: Google ranking factor, browsers show warnings without it, required for features like geolocation, and essential for customer trust in ecommerce." },
            { q: "What's the relationship between distance and latency?", opts: ["No relationship", "Speed of light limits: ~100ms London‚ÜíTokyo one-way. Each request = multiple roundtrips (DNS, TCP, TLS, HTTP). Far users = slow site unless you use CDN.", "Only affects downloads", "Software can fix it"], correct: 1, explain: "Physics: light travels ~200,000km/sec in fiber. London‚ÜíTokyo = 20,000km = 100ms one-way. Each request needs multiple roundtrips. CDN puts servers closer to users to reduce distance." }
        ],
        essay: { q: "Your site serves UK customers from a London server. Marketing wants to expand to US and Australia. Engineering says you need a CDN and estimates ¬£300/month. How do you evaluate if this is necessary? What's the customer experience without it?", guide: "Current: London server serves UK well (10-20ms latency). Without CDN: US users: 80ms+ per request √ó multiple requests = 2-3 second slowdown. Australia users: 150ms+ = 4-5 second slowdown. Impact: slow sites = abandoned carts, poor experience, negative reviews. With CDN: Serve from edge servers in US/Australia (20-30ms latency). Cost: ¬£300/mo vs lost sales. Calculate: if 1% conversion loss from slow US site, and US represents ¬£50k/month revenue, that's ¬£500/month lost. CDN pays for itself. Alternative: Regional servers (more expensive: ¬£500+/month). Recommendation: Start with CDN (Cloudflare/CloudFront), measure latency improvement, calculate conversion impact." }
    },


    // DAY 2 - CLIENT-SERVER ARCHITECTURE & APIS
    {
        day: 2,
        week: 0,
        title: "Client-Server Architecture & APIs",
        desc: "How frontend and backend communicate",
        duration: "50 min",
        coldOpen: "Your mobile app team says they need a separate API. Web team says they can share the existing one. CTO proposes GraphQL instead of REST. What's the right approach?",
        coldRevisit: "Different clients (web, mobile, third-party) often need different data shapes. REST works for simple cases. GraphQL helps when clients need flexible queries. Start simple (REST), add complexity only when needed.",
        content: "<h2>Why This Matters</h2><p>Your ecommerce site likely has a frontend (what users see) and backend (server, database). Understanding how they communicate helps you evaluate API design proposals and integration projects.</p><h2>1. Client-Server Model</h2><pre>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   CLIENT     ‚îÇ ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  ‚îÇ   SERVER     ‚îÇ\n‚îÇ (Browser/App)‚îÇ         ‚îÇ  (API/DB)    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nClient responsibilities:\n- Display UI\n- Handle user input\n- Make API requests\n- Render responses\n\nServer responsibilities:\n- Business logic\n- Database access\n- Authentication\n- Data processing</pre><h2>2. REST APIs: The Standard</h2><pre>// Get product\nGET /api/products/123\nResponse: { id: 123, name: 'Headphones', price: 149.99 }\n\n// List products\nGET /api/products?category=audio&sort=price\nResponse: [{ id: 123, ... }, { id: 124, ... }]\n\n// Create order\nPOST /api/orders\nBody: { productId: 123, quantity: 2 }\nResponse: { orderId: 'ORD-789', total: 299.98 }\n\n// Update product\nPUT /api/products/123\nBody: { price: 129.99 }\n\n// Delete product\nDELETE /api/products/123</pre><h3>REST Principles</h3><ul><li><strong>Resources:</strong> Products, orders, users (nouns)</li><li><strong>HTTP Verbs:</strong> GET (read), POST (create), PUT (update), DELETE (delete)</li><li><strong>Stateless:</strong> Each request independent, no session on server</li><li><strong>Standard formats:</strong> JSON responses</li></ul><h2>3. Common API Patterns</h2><table><tr><th>Pattern</th><th>When to Use</th><th>Example</th></tr><tr><td><strong>REST</strong></td><td>Standard CRUD operations</td><td>Product catalog, user management</td></tr><tr><td><strong>GraphQL</strong></td><td>Flexible querying, multiple clients</td><td>Mobile app needs different data than web</td></tr><tr><td><strong>Webhooks</strong></td><td>Event notifications (covered Day 18)</td><td>Payment succeeded, order shipped</td></tr><tr><td><strong>WebSockets</strong></td><td>Real-time bidirectional</td><td>Live chat, real-time inventory</td></tr></table><h2>4. API Versioning</h2><pre>// Version in URL (common)\nGET /api/v1/products\nGET /api/v2/products\n\n// Version in header (flexible)\nGET /api/products\nHeader: Accept: application/vnd.api+json;version=2\n\nWhy version?\n- Breaking changes don't break existing clients\n- Mobile apps can't force-update immediately\n- Third-party integrations need stability</pre><h2>5. API Documentation</h2><p>Good APIs need documentation:</p><ul><li><strong>Endpoints:</strong> What URLs exist?</li><li><strong>Parameters:</strong> What inputs required?</li><li><strong>Responses:</strong> What data returned?</li><li><strong>Examples:</strong> Working code samples</li><li><strong>Errors:</strong> What can go wrong?</li></ul><p>Tools: Swagger/OpenAPI, Postman</p>",
        questions: [
            { q: "Mobile team says they need 'just product name and price', but web needs 'everything'. Should you create separate APIs?", opts: ["Yes‚Äîseparate APIs for each client", "No‚Äîone API can return different data based on query parameters or use GraphQL to let clients specify exactly what they need. Don't duplicate logic.", "Create separate servers", "Mobile should use web API"], correct: 1, explain: "One API, flexible responses. REST: Use query params like ?fields=name,price. GraphQL: Let clients query exactly what they need. Separate APIs = duplicate logic, more maintenance." },
            { q: "What's the difference between PUT and POST?", opts: ["No difference", "POST creates new resource, PUT updates existing resource (or creates if you specify ID). POST to /products creates product. PUT to /products/123 updates product 123.", "PUT is faster", "POST is more secure"], correct: 1, explain: "REST conventions: POST creates (generates new ID), PUT updates (you specify ID). POST /products creates new. PUT /products/123 updates existing. This convention helps API users understand what each endpoint does." },
            { q: "Why do APIs need versioning?", opts: ["To track changes", "Breaking changes don't break existing clients. Mobile apps can't force-update. Third-party integrations need stability. v1 works while v2 adds features.", "Makes APIs faster", "Required by standards"], correct: 1, explain: "Version APIs to avoid breaking existing clients. If you change response format, old mobile apps break. Versioning lets old clients use v1 while new clients use v2. Critical for stability." },
            { q: "Your API returns 50 fields but frontend uses only 5. Problem?", opts: ["No problem‚Äîmore data is better", "Wastes bandwidth and slows responses. Large payloads slow mobile users. Solution: Let clients specify needed fields (?fields=name,price) or use GraphQL.", "Need faster server", "Should use POST instead"], correct: 1, explain: "Over-fetching wastes bandwidth. 50-field response when you need 5 = slow, especially on mobile. Solution: Query parameters to select fields, or GraphQL to request exactly what's needed." },
            { q: "When should you choose GraphQL over REST?", opts: ["Always‚ÄîGraphQL is newer", "When you have multiple clients (web, mobile, third-party) with different data needs, or complex nested queries. Don't use GraphQL if REST works‚Äîadds complexity.", "Never‚ÄîREST is standard", "Only for startups"], correct: 1, explain: "GraphQL solves specific problems: flexible querying, avoiding over/under-fetching, multiple client types. But adds complexity (learning curve, caching harder). Use REST unless you have these specific problems." }
        ],
        essay: { q: "Your mobile team wants a separate API because 'the web API returns too much data'. Your architect proposes GraphQL. Your CTO wants to keep REST simple. How do you evaluate these options? What are the trade-offs?", guide: "Current problem: Mobile uses 5 fields, web API returns 50. Options: 1) Separate mobile API: Duplicate logic, double maintenance, different bugs. Cost: High. Benefit: Mobile-optimized. 2) Add query params to REST: ?fields=name,price. Cost: Low (1-2 days). Benefit: Flexible, backward compatible. 3) GraphQL: Clients query exact needs. Cost: 2-4 weeks migration + learning curve. Benefit: Very flexible, solves problem long-term. Recommendation: Start with option 2 (query params). Measure if it solves problem. If mobile needs grow complex (nested data, many variations), consider GraphQL. Don't rewrite unless complexity justifies cost. Calculate: GraphQL migration = 4 weeks √ó 3 devs = ¬£96k. Query params = 2 days √ó 1 dev = ¬£1.6k. Start cheap, add complexity only if needed." }
    },

    // DAY 3 - DATABASES & DATA STORAGE
    {
        day: 3,
        week: 0,
        title: "Databases & Data Storage",
        desc: "SQL, NoSQL, choosing the right database",
        duration: "55 min",
        coldOpen: "Site is slow. Developer says 'we need MongoDB'. Your data is highly relational (customers, orders, products). Is NoSQL the answer?",
        coldRevisit: "Probably not. NoSQL solves specific problems. Relational databases (PostgreSQL, MySQL) excel at relational data. Don't cargo-cult tech trends.",
        content: "<h2>Why This Matters</h2><p>Your database stores everything. Wrong choice causes slow sites and expensive rewrites.</p><h2>SQL vs NoSQL</h2><p>SQL best for: structured data, relationships, transactions. NoSQL best for: massive scale, flexible schemas.</p>",
        questions: [
            { q: "Developer says SQL slow, proposes MongoDB. Users/orders/products with relationships. Response?", opts: ["Approve MongoDB", "Ask: Added indexes? Optimized queries? SQL excels at relational data.", "Switch to PostgreSQL", "Add RAM"], correct: 1, explain: "Slow SQL usually: missing indexes, N+1 queries. Fix SQL first." }
        ],
        essay: { q: "Evaluate MongoDB proposal for relational ecommerce data.", guide: "Diagnose: Check indexes, query optimization. SQL usually right for ecommerce." }
    },

    // DAY 4 - CACHING STRATEGIES
    { day: 4, week: 0, title: "Caching Strategies", desc: "Making sites fast with smart caching", duration: "50 min",
      coldOpen: "Your site serves same product pages thousands of times per day. Every request hits database. Can this be faster?",
      coldRevisit: "Yes‚Äîcaching. Store computed results, reuse them. Redis for data, CDN for static files, browser caching. Trade-off: complexity vs speed.",
      content: "<h2>Why Caching Matters</h2><p>Caching = storing expensive-to-compute results for reuse. Database queries take 50-200ms. Cache lookups take 1-5ms. 40x faster.</p><h2>Caching Layers</h2><table><tr><th>Layer</th><th>Speed</th><th>Use Case</th></tr><tr><td>Browser Cache</td><td>0ms</td><td>CSS, JS, images</td></tr><tr><td>CDN Cache</td><td>20-50ms</td><td>Static files globally</td></tr><tr><td>Redis Cache</td><td>1-5ms</td><td>Database query results</td></tr><tr><td>Database</td><td>50-200ms</td><td>Source of truth</td></tr></table><h2>Example</h2><pre>// Check Redis cache first\\nconst cached = await redis.get('product:123');\\nif (cached) return JSON.parse(cached);\\n\\n// Cache miss: query database\\nconst product = await db.query('SELECT * FROM products WHERE id = 123');\\nawait redis.setex('product:123', 300, JSON.stringify(product));\\nreturn product;</pre>",
      questions: [
        { q: "What's cache invalidation?", opts: ["Deleting cache", "Ensuring cached data stays fresh when source changes. Hard problem: when product price updates, invalidate cache.", "Cache security", "Backup"], correct: 1, explain: "Cache invalidation = removing stale data. Product price changes? Clear cache so users see new price." }
      ],
      essay: { q: "Evaluate caching strategy for product pages.", guide: "Cache product data in Redis (5-min TTL). Invalidate on updates. CDN for images." }
    },
    // DAY 5 - CDN & EDGE COMPUTING
    { day: 5, week: 0, title: "CDNs & Edge Computing", desc: "Serving content globally", duration: "50 min",
      coldOpen: "Australian users say site is slow. You're hosted in London. CDN costs ¬£300/month. Worth it?",
      coldRevisit: "Yes. London‚ÜíAustralia = 300ms latency per request. CDN = 20-30ms. Users get fast experience.",
      content: "<h2>How CDNs Work</h2><p>CDN = Content Delivery Network. Copies your static files to servers worldwide.</p><h2>Without CDN</h2><pre>Sydney user ‚Üí London server (300ms) √ó 50 resources = 15sec</pre><h2>With CDN</h2><pre>Sydney user ‚Üí Sydney CDN edge (20ms) √ó 50 resources = 1sec</pre>",
      questions: [
        { q: "CDN for UK-only site?", opts: ["Not needed", "Yes‚ÄîDDoS protection, cheaper bandwidth, faster even within UK.", "Only for global", "Too expensive"], correct: 1, explain: "CDN helps single-country sites: DDoS protection, bandwidth savings, multiple edges." }
      ],
      essay: { q: "Evaluate ¬£300/month CDN for UK site expanding to US.", guide: "Calculate: slow site = lost conversions. CDN pays for itself." }
    },
    // DAY 6 - LOAD BALANCING & SCALING
    { day: 6, week: 0, title: "Load Balancing & Scaling", desc: "Handling traffic spikes", duration: "50 min",
      coldOpen: "Black Friday: traffic 10x normal. Site crashed last year. Bigger server or multiple servers?",
      coldRevisit: "Multiple servers + load balancer. Horizontal scaling > vertical scaling.",
      content: "<h2>Scaling</h2><p>Vertical (scale up) = bigger server. Horizontal (scale out) = more servers.</p><h2>Load Balancer</h2><pre>Internet ‚Üí Load Balancer ‚Üí Server 1\\n‚Üí Server 2\\n‚Üí Server 3</pre>",
      questions: [
        { q: "What does load balancer do?", opts: ["Makes faster", "Distributes traffic across servers. If one crashes, routes to healthy servers.", "Balances DB", "Cache"], correct: 1, explain: "Load balancer = traffic distributor. Spreads requests, health checks, removes failed servers." }
      ],
      essay: { q: "Plan Black Friday scaling.", guide: "Add load balancer + more servers. Test beforehand. Monitor. Auto-scaling ideal." }
    },
    // DAY 7 - WEEK 1 REVIEW
    { day: 7, week: 0, title: "Week 1 Review", desc: "Infrastructure foundations", duration: "45 min",
      coldOpen: "Board asks: 'Is our technical foundation solid?'",
      coldRevisit: "Assess: Fast globally? Database optimized? Caching? Handle spikes? Secure? Monitored?",
      content: "<h2>Week 1 Key Takeaways</h2><ul><li>Web basics: DNS, HTTP, distance</li><li>APIs: REST, versioning</li><li>Databases: SQL for relational, indexes</li><li>Caching: Redis, CDN</li><li>Scaling: Horizontal, load balancers</li></ul>",
      questions: [
        { q: "Infrastructure priorities for new site?", opts: ["Microservices", "HTTPS, indexes, caching, monitoring. Start simple.", "NoSQL", "Kubernetes"], correct: 1, explain: "Start with fundamentals. Don't over-engineer." }
      ],
      essay: { q: "Create infrastructure health report.", guide: "Assess: speed, reliability, scalability, security. Identify gaps, prioritize, estimate costs." }
    },

    // DAY 8 - HTML5 SEMANTICS & ACCESSIBILITY
    {
        day: 8,
        week: 1,
        title: "HTML5 Semantics & Accessibility",
        desc: "Meaningful markup and inclusive design",
        duration: "55 min",
        coldOpen: "Legal warns about accessibility lawsuit risk. Your competitor just settled for ¬£500k. The dev team says our site works fine. What do you need to know?",
        coldRevisit: "Accessibility is a legal requirement in many jurisdictions (ADA, EAA, WCAG). 'Works fine' often means 'works for people like us'. 15% of users have disabilities. Semantic HTML helps everyone‚Äîscreen readers, SEO, and maintenance.",
        content: "<h2>Why This Matters to You</h2><p>Accessibility isn't just about compliance‚Äîthough the legal risk is real. In 2023, over 4,000 web accessibility lawsuits were filed in the US alone. But beyond legal risk, accessible sites reach more customers, rank better in search, and are easier to maintain.</p><h2>1. Semantic HTML: Meaning Over Appearance</h2><p>HTML elements carry meaning. Using the right element helps browsers, search engines, and assistive technologies understand your content.</p><pre>&lt;!-- Bad: Divs mean nothing to assistive technology --&gt;\n&lt;div class=\"header\"&gt;\n  &lt;div class=\"nav\"&gt;\n    &lt;div class=\"nav-item\"&gt;Products&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- Good: Semantic elements convey structure --&gt;\n&lt;header&gt;\n  &lt;nav&gt;\n    &lt;a href=\"/products\"&gt;Products&lt;/a&gt;\n  &lt;/nav&gt;\n&lt;/header&gt;</pre><h3>Key Semantic Elements</h3><table><tr><th>Element</th><th>Purpose</th><th>Screen Reader Behavior</th></tr><tr><td><code>&lt;header&gt;</code></td><td>Page or section header</td><td>Announced as banner landmark</td></tr><tr><td><code>&lt;nav&gt;</code></td><td>Navigation links</td><td>Announced as navigation landmark</td></tr><tr><td><code>&lt;main&gt;</code></td><td>Primary content</td><td>Users can skip directly to main content</td></tr><tr><td><code>&lt;article&gt;</code></td><td>Self-contained content</td><td>Announced as article</td></tr><tr><td><code>&lt;aside&gt;</code></td><td>Related but separate content</td><td>Announced as complementary</td></tr><tr><td><code>&lt;footer&gt;</code></td><td>Page or section footer</td><td>Announced as contentinfo landmark</td></tr><tr><td><code>&lt;button&gt;</code></td><td>Clickable action</td><td>Announced as button, keyboard accessible</td></tr></table><div class=\"info-box\"><div class=\"info-title\">üí° The Landmark Test</div><p>Screen reader users navigate by landmarks (header, nav, main, footer). If your site is all divs, they hear nothing useful. Ask your team: Can a screen reader user navigate our site by landmarks?</p></div><h2>2. Accessibility Fundamentals (WCAG)</h2><p>Web Content Accessibility Guidelines (WCAG) define accessibility standards. Level AA is typically the legal requirement.</p><h3>The Four Principles: POUR</h3><table><tr><th>Principle</th><th>Meaning</th><th>Example Requirement</th></tr><tr><td><strong>Perceivable</strong></td><td>Users can perceive content</td><td>Images have alt text, videos have captions</td></tr><tr><td><strong>Operable</strong></td><td>Users can interact</td><td>Everything works with keyboard, no seizure-inducing flashes</td></tr><tr><td><strong>Understandable</strong></td><td>Content is clear</td><td>Consistent navigation, error messages explain how to fix</td></tr><tr><td><strong>Robust</strong></td><td>Works with assistive tech</td><td>Valid HTML, ARIA used correctly</td></tr></table><h2>3. Common Accessibility Failures</h2><h3>Images Without Alt Text</h3><pre>&lt;!-- Bad: Screen reader says \"image\" or reads filename --&gt;\n&lt;img src=\"product-xyz-123.jpg\"&gt;\n\n&lt;!-- Good: Descriptive alt text --&gt;\n&lt;img src=\"product-xyz-123.jpg\" alt=\"Blue wireless headphones with noise cancellation\"&gt;\n\n&lt;!-- Good: Decorative image, empty alt --&gt;\n&lt;img src=\"decorative-swoosh.png\" alt=\"\"&gt;</pre><h3>Fake Buttons</h3><pre>&lt;!-- Bad: Looks like button but isn't accessible --&gt;\n&lt;div class=\"button\" onclick=\"addToCart()\"&gt;Add to Cart&lt;/div&gt;\n\n&lt;!-- Problems: --&gt;\n&lt;!-- - Can't be focused with Tab key --&gt;\n&lt;!-- - Screen reader doesn't announce as button --&gt;\n&lt;!-- - Enter/Space don't activate it --&gt;\n\n&lt;!-- Good: Real button with all accessibility built in --&gt;\n&lt;button onclick=\"addToCart()\"&gt;Add to Cart&lt;/button&gt;</pre><h3>Color-Only Information</h3><pre>&lt;!-- Bad: Color alone indicates sale --&gt;\n&lt;span class=\"red\"&gt;¬£49.99&lt;/span&gt;  &lt;!-- Colorblind users can't tell --&gt;\n\n&lt;!-- Good: Text and icon supplement color --&gt;\n&lt;span class=\"sale-price\"&gt;\n  &lt;span class=\"visually-hidden\"&gt;Sale price:&lt;/span&gt;\n  ¬£49.99 üè∑Ô∏è\n&lt;/span&gt;</pre><h3>Missing Form Labels</h3><pre>&lt;!-- Bad: Placeholder disappears, no label for screen reader --&gt;\n&lt;input type=\"email\" placeholder=\"Email address\"&gt;\n\n&lt;!-- Good: Proper label association --&gt;\n&lt;label for=\"email\"&gt;Email address&lt;/label&gt;\n&lt;input type=\"email\" id=\"email\"&gt;</pre><h2>4. Keyboard Navigation</h2><p>Many users can't use a mouse‚Äîmotor impairments, screen reader users, power users. Everything must work with keyboard alone.</p><h3>Key Requirements</h3><ul><li><strong>Tab order:</strong> Focus moves logically through the page</li><li><strong>Visible focus:</strong> Users can see which element is focused</li><li><strong>No keyboard traps:</strong> Users can always Tab out of any component</li><li><strong>Skip links:</strong> Skip to main content link for keyboard users</li></ul><pre>&lt;!-- Skip link (usually visually hidden until focused) --&gt;\n&lt;a href=\"#main-content\" class=\"skip-link\"&gt;Skip to main content&lt;/a&gt;\n\n&lt;!-- CSS to show skip link on focus --&gt;\n.skip-link {\n  position: absolute;\n  left: -9999px;\n}\n.skip-link:focus {\n  left: 10px;\n  top: 10px;\n}</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The Tab Test</div><p>Try navigating your site using only the Tab key and Enter. Can you: reach all interactive elements? See where focus is? Complete a purchase? If not, keyboard users can't either.</p></div><h2>5. Color Contrast</h2><p>WCAG requires minimum contrast ratios between text and background:</p><ul><li><strong>Normal text:</strong> 4.5:1 ratio minimum</li><li><strong>Large text (18px+ bold or 24px+):</strong> 3:1 ratio minimum</li><li><strong>UI components and graphics:</strong> 3:1 ratio minimum</li></ul><p>Tools like WebAIM Contrast Checker can verify your colors meet requirements.</p><h2>6. ARIA: Use Sparingly</h2><p>ARIA (Accessible Rich Internet Applications) adds accessibility information to HTML. But the first rule of ARIA is: don't use ARIA if native HTML works.</p><pre>&lt;!-- Unnecessary ARIA: button is already accessible --&gt;\n&lt;button role=\"button\" aria-label=\"Submit\"&gt;Submit&lt;/button&gt;\n\n&lt;!-- Necessary ARIA: custom component needs ARIA --&gt;\n&lt;div role=\"tablist\"&gt;\n  &lt;button role=\"tab\" aria-selected=\"true\" aria-controls=\"panel1\"&gt;Tab 1&lt;/button&gt;\n  &lt;button role=\"tab\" aria-selected=\"false\" aria-controls=\"panel2\"&gt;Tab 2&lt;/button&gt;\n&lt;/div&gt;</pre><h2>7. Testing Accessibility</h2><h3>Automated Tools (Find ~30% of Issues)</h3><ul><li><strong>axe DevTools:</strong> Browser extension, catches common issues</li><li><strong>WAVE:</strong> Visual overlay showing issues</li><li><strong>Lighthouse:</strong> Built into Chrome DevTools</li></ul><h3>Manual Testing (Essential)</h3><ul><li><strong>Keyboard navigation:</strong> Tab through entire site</li><li><strong>Screen reader:</strong> Use VoiceOver (Mac), NVDA (Windows), or JAWS</li><li><strong>Zoom to 200%:</strong> Content should remain usable</li><li><strong>Disable CSS:</strong> Content should still be logical</li></ul><div class=\"exercise\"><h4>üîß Practical Exercise</h4><ol><li>Install axe DevTools browser extension</li><li>Run it on your product page</li><li>Try navigating checkout with keyboard only</li><li>Document: How many issues found? Can checkout be completed?</li></ol></div>",
        questions: [
            { q: "Your site uses div onclick for all buttons. Dev says it works fine. What's wrong?", opts: ["Nothing‚ÄîJavaScript handles the click", "Screen readers can't identify it as interactive; keyboard users can't Tab to it or activate with Enter", "Divs are slower than buttons", "Only affects old browsers"], correct: 1, explain: "Native button elements are focusable, keyboard operable, and announced correctly by screen readers‚Äîfor free. Divs need extensive ARIA and JavaScript to achieve the same." },
            { q: "Images have alt=\"\" (empty). When is this correct?", opts: ["Never‚Äîall images need descriptions", "When the image is purely decorative and adds no information", "Always‚Äîfor faster loading", "Only for background images"], correct: 1, explain: "Decorative images should have empty alt so screen readers skip them. Informative images need descriptive alt text." },
            { q: "WCAG 2.1 Level AA is often the legal standard. What does this practically mean?", opts: ["A certification you can purchase", "Specific technical requirements for color contrast, keyboard access, text alternatives, and more", "A grade from an auditor", "Only applies to government sites"], correct: 1, explain: "WCAG AA includes specific, testable requirements. Level A is minimum, AA is standard requirement, AAA is enhanced." },
            { q: "Your sale prices are red, regular prices are black. A customer complains they can't tell what's on sale. Why?", opts: ["Red is hard to see on screens", "Approximately 8% of men are colorblind. Color alone shouldn't convey information‚Äîneed icon, text, or pattern too.", "They need a better monitor", "CSS issue"], correct: 1, explain: "Color blindness affects 1 in 12 men. Use multiple indicators: color AND text label AND/OR icon." },
            { q: "Developer says adding accessibility will slow down the project. Your response?", opts: ["Accessibility can wait until v2", "Building accessibly from the start is faster than retrofitting. It's also a legal requirement. What specific concerns do you have?", "Hire an accessibility specialist", "Skip accessibility for MVP"], correct: 1, explain: "Retrofitting accessibility is 10x more expensive than building it in. Legal risk is real. Address specific concerns rather than accepting delay." }
        ],
        essay: { q: "Audit your company's checkout flow for accessibility. What issues exist? What is the business and legal risk?", guide: "Run axe DevTools, test with keyboard only, check color contrast on buttons. Consider: legal exposure, lost sales from excluded users, brand reputation. Prioritize fixes by severity." }
    },
    
    // PLACEHOLDER: Days 9-30 with titles and structure
    // Add your comprehensive content for each day below
    // DAY 9 - CSS ARCHITECTURE & LAYOUT
    {
        day: 9,
        week: 1,
        title: "CSS Architecture & Layout",
        desc: "Modern CSS, Flexbox, Grid, and scalable stylesheets",
        duration: "55 min",
        coldOpen: "Your lead developer says your CSS is unmaintainable and proposes a 3-month rewrite. Marketing wants a homepage redesign next week. How do you evaluate if a rewrite is necessary?",
        coldRevisit: "CSS rewrites are expensive and rarely necessary. Most 'messy CSS' problems stem from lack of system, not the CSS itself. Modern CSS (Flexbox, Grid, custom properties) can often fix issues incrementally without a full rewrite.",
        content: "<h2>Why This Matters to You</h2><p>CSS seems simple‚Äîit's just styling, right? But CSS is where many ecommerce sites struggle. Poor CSS architecture leads to slow development, inconsistent branding, and expensive maintenance. A 3-month CSS rewrite costs ¬£200k+ in developer time, but proper CSS architecture prevents these problems in the first place.</p><h2>1. Understanding CSS Architecture Problems</h2><p>When developers say 'CSS is a mess', they usually mean one of these:</p><table><tr><th>Problem</th><th>Symptoms</th><th>Root Cause</th></tr><tr><td><strong>Specificity Wars</strong></td><td>Styles overriding each other, need !important everywhere</td><td>No clear selector strategy, IDs mixed with classes</td></tr><tr><td><strong>Dead Code</strong></td><td>Afraid to delete CSS‚Äîmight break something</td><td>No component boundaries or naming system</td></tr><tr><td><strong>Duplication</strong></td><td>Same color defined 47 times in different values</td><td>No design tokens or CSS variables</td></tr><tr><td><strong>Layout Hacks</strong></td><td>Magic numbers, negative margins, absolute positioning everywhere</td><td>Not using modern layout tools (Flexbox, Grid)</td></tr></table><div class=\"info-box\"><div class=\"info-title\">üí° The Real Question</div><p>Before approving a rewrite, ask: 'What specific problems are we solving, and can we solve them incrementally?' A rewrite should be the last resort, not the first instinct.</p></div><h2>2. Modern CSS Layout: Flexbox</h2><p>Flexbox is designed for one-dimensional layouts‚Äîrows or columns. It's perfect for navigation, card layouts, and flexible components.</p><h3>Core Flexbox Concepts</h3><pre>/* Parent container */\n.nav {\n  display: flex;\n  justify-content: space-between;  /* Horizontal alignment */\n  align-items: center;             /* Vertical alignment */\n  gap: 20px;                       /* Space between items */\n}\n\n/* Child items */\n.nav-item {\n  flex: 1;        /* Grow to fill space */\n  /* flex: 0 0 200px;  Fixed width item */\n}</pre><h3>Common Flexbox Patterns</h3><pre>/* Horizontal navigation with logo left, links right */\n.header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n/* Evenly spaced product cards */\n.product-grid {\n  display: flex;\n  flex-wrap: wrap;  /* Wrap to next line */\n  gap: 20px;\n}\n.product-card {\n  flex: 1 1 300px;  /* Grow, shrink, min-width */\n}\n\n/* Centered content (vertically and horizontally) */\n.modal {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n}</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è Common Flexbox Mistake</div><p>Using Flexbox for two-dimensional layouts (rows AND columns). That's what Grid is for. Flexbox is for one dimension at a time.</p></div><h2>3. Modern CSS Layout: Grid</h2><p>CSS Grid is designed for two-dimensional layouts‚Äîrows and columns simultaneously. It's perfect for page layouts, dashboards, and complex arrangements.</p><h3>Basic Grid Example</h3><pre>/* 3-column product grid */\n.product-grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);  /* 3 equal columns */\n  gap: 20px;\n}\n\n/* Responsive: 1 column on mobile, 2 on tablet, 3 on desktop */\n.product-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n  gap: 20px;\n}</pre><h3>Complex Grid Layout</h3><pre>/* Dashboard layout with header, sidebar, main, footer */\n.dashboard {\n  display: grid;\n  grid-template-areas:\n    \"header header header\"\n    \"sidebar main main\"\n    \"footer footer footer\";\n  grid-template-columns: 250px 1fr 1fr;\n  grid-template-rows: auto 1fr auto;\n  min-height: 100vh;\n  gap: 20px;\n}\n\n.header  { grid-area: header; }\n.sidebar { grid-area: sidebar; }\n.main    { grid-area: main; }\n.footer  { grid-area: footer; }</pre><h2>4. CSS Custom Properties (Variables)</h2><p>Custom properties solve the duplication problem and enable theming. Define once, use everywhere.</p><pre>/* Define in :root for global access */\n:root {\n  /* Colors - from design system */\n  --color-brand: #0066cc;\n  --color-success: #00cc66;\n  --color-error: #cc0000;\n  --color-text: #333333;\n  --color-text-light: #666666;\n  \n  /* Spacing - consistent rhythm */\n  --space-xs: 4px;\n  --space-sm: 8px;\n  --space-md: 16px;\n  --space-lg: 24px;\n  --space-xl: 32px;\n  \n  /* Typography */\n  --font-body: 'Inter', sans-serif;\n  --font-heading: 'Poppins', sans-serif;\n  --text-sm: 14px;\n  --text-base: 16px;\n  --text-lg: 20px;\n}\n\n/* Use everywhere */\n.button {\n  background: var(--color-brand);\n  color: white;\n  padding: var(--space-md) var(--space-lg);\n  font-family: var(--font-body);\n}\n\n/* Easy theming */\n[data-theme=\"dark\"] {\n  --color-text: #ffffff;\n  --color-background: #1a1a1a;\n}</pre><div class=\"exercise\"><h4>üîß Practical Exercise</h4><p>Audit your CSS for magic numbers and repeated values:</p><ol><li>Search for <code>color:</code> in your stylesheets. How many unique color values? Should be ~10-15 max.</li><li>Search for <code>font-size:</code>. How many unique sizes? Should be 5-8 max.</li><li>Convert repeated values to CSS custom properties.</li></ol></div><h2>5. CSS Naming Methodologies: BEM</h2><p>BEM (Block Element Modifier) is a naming convention that makes CSS predictable and maintainable.</p><h3>BEM Structure</h3><pre>/* Block: standalone component */\n.product-card { }\n\n/* Element: part of the block (uses __) */\n.product-card__image { }\n.product-card__title { }\n.product-card__price { }\n.product-card__button { }\n\n/* Modifier: variant of block or element (uses --) */\n.product-card--featured { }\n.product-card--out-of-stock { }\n.product-card__button--primary { }\n.product-card__button--secondary { }</pre><h3>Why BEM Works</h3><ul><li><strong>No specificity issues:</strong> All classes have same specificity</li><li><strong>Clear relationships:</strong> Name shows what component it belongs to</li><li><strong>Safe to delete:</strong> Search for <code>.product-card</code> shows all related CSS</li><li><strong>No conflicts:</strong> Long names prevent accidental collisions</li></ul><h2>6. CSS Organization Strategies</h2><p>Organize CSS files by purpose, not by page.</p><pre>styles/\n‚îú‚îÄ‚îÄ 1-settings/\n‚îÇ   ‚îú‚îÄ‚îÄ _variables.css      /* Custom properties */\n‚îÇ   ‚îî‚îÄ‚îÄ _tokens.css         /* Design tokens */\n‚îú‚îÄ‚îÄ 2-tools/\n‚îÇ   ‚îî‚îÄ‚îÄ _mixins.css         /* Reusable patterns */\n‚îú‚îÄ‚îÄ 3-generic/\n‚îÇ   ‚îú‚îÄ‚îÄ _reset.css          /* Normalize browser styles */\n‚îÇ   ‚îî‚îÄ‚îÄ _box-sizing.css     /* Global defaults */\n‚îú‚îÄ‚îÄ 4-elements/\n‚îÇ   ‚îú‚îÄ‚îÄ _typography.css     /* h1, p, a styles */\n‚îÇ   ‚îî‚îÄ‚îÄ _forms.css          /* input, button styles */\n‚îú‚îÄ‚îÄ 5-components/\n‚îÇ   ‚îú‚îÄ‚îÄ _button.css         /* .button */\n‚îÇ   ‚îú‚îÄ‚îÄ _card.css           /* .card */\n‚îÇ   ‚îú‚îÄ‚îÄ _modal.css          /* .modal */\n‚îÇ   ‚îî‚îÄ‚îÄ _navigation.css     /* .nav */\n‚îú‚îÄ‚îÄ 6-utilities/\n‚îÇ   ‚îî‚îÄ‚îÄ _helpers.css        /* .hidden, .text-center */\n‚îî‚îÄ‚îÄ main.css                /* Imports all others */\n</pre><h2>7. Responsive Design Principles</h2><p>Mobile-first approach: start with mobile styles, add complexity for larger screens.</p><pre>/* Mobile first: base styles for small screens */\n.product-grid {\n  display: grid;\n  grid-template-columns: 1fr;  /* 1 column on mobile */\n  gap: 16px;\n}\n\n/* Tablet: 2 columns at 600px+ */\n@media (min-width: 600px) {\n  .product-grid {\n    grid-template-columns: repeat(2, 1fr);\n    gap: 20px;\n  }\n}\n\n/* Desktop: 3 columns at 900px+ */\n@media (min-width: 900px) {\n  .product-grid {\n    grid-template-columns: repeat(3, 1fr);\n    gap: 24px;\n  }\n}\n\n/* Large desktop: 4 columns at 1200px+ */\n@media (min-width: 1200px) {\n  .product-grid {\n    grid-template-columns: repeat(4, 1fr);\n  }\n}</pre><div class=\"info-box\"><div class=\"info-title\">üí° Breakpoint Strategy</div><p>Don't use device-specific breakpoints like 'iPhone' or 'iPad'. Use content-based breakpoints: where does your design break? That's your breakpoint.</p></div><h2>8. When to Rewrite vs. Refactor</h2><table><tr><th>Situation</th><th>Recommendation</th><th>Why</th></tr><tr><td>Using tables for layout</td><td>Rewrite incrementally</td><td>Modern layout (Flexbox/Grid) is essential</td></tr><tr><td>No naming system</td><td>Adopt BEM, refactor gradually</td><td>Can be done per-component without breaking site</td></tr><tr><td>Colors/sizes repeated</td><td>Add CSS variables incrementally</td><td>Find-and-replace is safe and quick</td></tr><tr><td>Too much !important</td><td>Flatten specificity gradually</td><td>Fix highest-traffic pages first</td></tr><tr><td>Large unused CSS</td><td>Audit with coverage tools, remove safely</td><td>Low risk, high reward</td></tr></table><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The Rewrite Trap</div><p>A full CSS rewrite takes 2-3x longer than estimated, introduces new bugs, and doesn't guarantee better architecture. Always prefer incremental refactoring unless the technical debt is truly insurmountable.</p></div>",
        questions: [
            { q: "Your product grid uses float-based layout from 2010. Developer proposes 3-month rewrite. What should you do first?", opts: ["Approve the 3-month rewrite immediately", "Ask: Can we replace float with CSS Grid incrementally, page by page, starting with highest-traffic pages?", "Keep using floats‚Äîif it works, don't fix it", "Hire a CSS specialist"], correct: 1, explain: "Incremental refactoring is safer and faster. Convert one page at a time, test, and deploy. Full rewrites are rarely necessary and often introduce new bugs." },
            { q: "Your CSS has the same blue color defined 47 times with slightly different hex values. What's the systematic fix?", opts: ["Find-and-replace all to one value", "Define CSS custom property --color-brand once, replace all instances with var(--color-brand)", "Leave it‚Äîconsistency doesn't matter", "Rewrite all CSS"], correct: 1, explain: "CSS custom properties (variables) solve duplication. Define once in :root, use everywhere. Easy to change and maintain." },
            { q: "Designer wants a 4-column product grid on desktop, 2 on tablet, 1 on mobile. What's the modern CSS approach?", opts: ["Create three separate layouts with JavaScript", "Use CSS Grid with media queries: 1 column base, 2 at 600px, 4 at 1200px", "Use Flexbox for everything", "Use CSS Grid without media queries"], correct: 1, explain: "CSS Grid with mobile-first media queries is the standard modern approach. Start with 1 column, add breakpoints as screen size increases." },
            { q: "Developer says you need !important everywhere because specificity is broken. What's the real problem?", opts: ["CSS is fundamentally flawed", "Too many IDs or overly specific selectors creating specificity wars. Need flatter hierarchy with single classes (like BEM).", "!important is the correct solution", "Need to use inline styles"], correct: 1, explain: "Needing !important everywhere indicates specificity problems. BEM methodology uses only single classes, giving flat specificity that's easy to manage." },
            { q: "How do you evaluate if a CSS 'mess' requires a full rewrite?", opts: ["If developers say it's messy, trust them and approve rewrite", "Identify specific problems (specificity? duplication? layout?), assess if they can be fixed incrementally, rewrite only if incremental fixes are impossible", "Always rewrite every 2 years", "Never rewrite, always add more CSS"], correct: 1, explain: "Most CSS problems can be fixed incrementally. Identify root causes, fix component by component. Full rewrites should be last resort when incremental fixes are truly impossible." }
        ],
        essay: { q: "Your developer proposes a 3-month CSS rewrite. What questions do you ask to evaluate if it's necessary? How would you assess the business risk and propose alternatives?", guide: "Ask: What specific problems are we solving? Can these be fixed incrementally? What's the risk of breaking existing functionality? Investigate: Run CSS coverage audit, identify unused code, check for modern layout usage. Propose: Incremental refactoring starting with highest-traffic pages, CSS variables for design tokens, BEM naming for new components. Calculate cost: 3 months dev time vs. incremental approach. Assess risk: Rewrite breaks everything at once vs. incremental changes contain risk." }
    },
    // DAY 10 - CORE WEB VITALS & PERFORMANCE
    {
        day: 10,
        week: 1,
        title: "Core Web Vitals & Performance",
        desc: "LCP, INP, CLS and business impact",
        duration: "55 min",
        coldOpen: "Your SEO agency says Google is penalizing your site for poor Core Web Vitals. Your product pages are slow, but conversions haven't dropped. Do you prioritize this? How much should you spend?",
        coldRevisit: "Core Web Vitals are a confirmed Google ranking factor. But more importantly: 1-second delay reduces conversions by 7% (Amazon data). Speed IS revenue. Field data (real users) matters more than lab scores.",
        content: "<h2>Why This Matters to You</h2><p>Page speed directly impacts revenue. Amazon found that every 100ms of latency costs them 1% in sales. Google uses Core Web Vitals as a ranking factor. But the real impact is user experience: slow sites lose customers. Understanding Core Web Vitals helps you prioritize performance investments effectively.</p><h2>1. The Three Core Web Vitals</h2><p>Google measures three key metrics from real user data. These are the Core Web Vitals:</p><table><tr><th>Metric</th><th>Measures</th><th>Good Threshold</th><th>What It Means</th></tr><tr><td><strong>LCP</strong><br>(Largest Contentful Paint)</td><td>Loading performance</td><td>&lt; 2.5 seconds</td><td>How quickly the main content appears</td></tr><tr><td><strong>INP</strong><br>(Interaction to Next Paint)</td><td>Interactivity</td><td>&lt; 200ms</td><td>How quickly the site responds to clicks/taps</td></tr><tr><td><strong>CLS</strong><br>(Cumulative Layout Shift)</td><td>Visual stability</td><td>&lt; 0.1</td><td>How much the page jumps around while loading</td></tr></table><div class=\"info-box\"><div class=\"info-title\">üí° Field Data vs. Lab Data</div><p><strong>Lab data</strong> (Lighthouse, PageSpeed Insights): Tests in perfect conditions, useful for debugging.<br><strong>Field data</strong> (Chrome User Experience Report): Real users, real connections, real devices‚Äîthis is what Google uses for ranking.</p></div><h2>2. LCP: Largest Contentful Paint</h2><p>LCP measures how long it takes for the largest visible element to appear. For ecommerce, this is usually the hero image or main product image.</p><h3>Common LCP Problems</h3><table><tr><th>Problem</th><th>Impact</th><th>Solution</th></tr><tr><td>Huge image files (5MB product photo)</td><td>Slow download</td><td>Optimize images: use WebP format, responsive images, compress to &lt;200KB</td></tr><tr><td>Image not prioritized</td><td>Downloads last</td><td>Add fetchpriority=\"high\" to hero/product image</td></tr><tr><td>Render-blocking CSS/JS</td><td>Image can't display until CSS loads</td><td>Inline critical CSS, defer non-critical JavaScript</td></tr><tr><td>Slow server response</td><td>HTML takes 3+ seconds</td><td>Use CDN, cache HTML, optimize database queries</td></tr></table><h3>Optimizing LCP: Practical Example</h3><pre>&lt;!-- Bad: Large image, no optimization --&gt;\n&lt;img src=\"product-huge.jpg\" alt=\"Product\"&gt;\n\n&lt;!-- Good: Optimized with modern format, priority hint --&gt;\n&lt;img \n  src=\"product-800w.webp\"\n  srcset=\"product-400w.webp 400w,\n          product-800w.webp 800w,\n          product-1200w.webp 1200w\"\n  sizes=\"(max-width: 600px) 400px,\n         (max-width: 1200px) 800px,\n         1200px\"\n  alt=\"Blue wireless headphones\"\n  fetchpriority=\"high\"\n  width=\"800\"\n  height=\"600\"\n&gt;</pre><div class=\"exercise\"><h4>üîß Quick LCP Check</h4><ol><li>Open Chrome DevTools ‚Üí Lighthouse</li><li>Run audit on your product page</li><li>Check LCP score‚Äîwhat's the largest element?</li><li>Is it optimized? What's the image file size?</li></ol></div><h2>3. INP: Interaction to Next Paint</h2><p>INP measures how quickly your site responds when users click buttons, open menus, or interact. This replaced FID (First Input Delay) in 2024.</p><h3>What Causes Slow INP?</h3><ul><li><strong>Heavy JavaScript:</strong> Blocking the main thread with computation</li><li><strong>Large DOM:</strong> 5000+ elements make updates slow</li><li><strong>Third-party scripts:</strong> Chat widgets, analytics blocking interactions</li><li><strong>No loading states:</strong> User doesn't know site is working</li></ul><h3>Improving INP</h3><pre>// Bad: Heavy work on click blocks interaction\nbutton.addEventListener('click', () => {\n  // Synchronous processing blocks UI\n  const result = processHugeDataset();\n  updateUI(result);\n});\n\n// Good: Show immediate feedback, defer heavy work\nbutton.addEventListener('click', async () => {\n  button.disabled = true;\n  button.textContent = 'Processing...';\n  \n  // Defer heavy work\n  const result = await processHugeDataset();\n  \n  updateUI(result);\n  button.disabled = false;\n  button.textContent = 'Complete';\n});</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The Add to Cart Test</div><p>Click 'Add to Cart' on your site. How long until you see feedback? If it's more than 200ms, INP is poor. Users perceive delays over 100ms as sluggish.</p></div><h2>4. CLS: Cumulative Layout Shift</h2><p>CLS measures how much the page layout shifts unexpectedly as it loads. Ever tried to click a button, but an ad loaded and you clicked the wrong thing? That's CLS.</p><h3>Common CLS Problems</h3><table><tr><th>Cause</th><th>Example</th><th>Fix</th></tr><tr><td>Images without dimensions</td><td>Content jumps down when image loads</td><td>Always specify width and height attributes</td></tr><tr><td>Ads without reserved space</td><td>Content shifts when ad loads</td><td>Reserve space with min-height container</td></tr><tr><td>Web fonts loading</td><td>Text shifts when font loads</td><td>Use font-display: swap and similar font fallbacks</td></tr><tr><td>Dynamically injected content</td><td>Banners appear, pushing content down</td><td>Reserve space or add above viewport</td></tr></table><h3>Fixing CLS: Image Example</h3><pre>&lt;!-- Bad: No dimensions, causes layout shift --&gt;\n&lt;img src=\"product.jpg\" alt=\"Product\"&gt;\n\n&lt;!-- Good: Dimensions prevent shift --&gt;\n&lt;img \n  src=\"product.jpg\" \n  alt=\"Product\"\n  width=\"800\"\n  height=\"600\"\n&gt;\n\n&lt;!-- Modern: Aspect ratio box --&gt;\n&lt;div style=\"aspect-ratio: 4/3\"&gt;\n  &lt;img src=\"product.jpg\" alt=\"Product\" style=\"width:100%;height:100%;object-fit:cover\"&gt;\n&lt;/div&gt;</pre><h2>5. Measuring Core Web Vitals</h2><h3>Tools for Measurement</h3><table><tr><th>Tool</th><th>Data Type</th><th>Best For</th></tr><tr><td><strong>PageSpeed Insights</strong></td><td>Lab + Field</td><td>Overview of performance</td></tr><tr><td><strong>Chrome DevTools Lighthouse</strong></td><td>Lab</td><td>Local debugging</td></tr><tr><td><strong>Search Console (Core Web Vitals report)</strong></td><td>Field</td><td>Google's actual ranking data</td></tr><tr><td><strong>Web Vitals Extension</strong></td><td>Real-time</td><td>Testing as you browse</td></tr><tr><td><strong>Real User Monitoring (RUM)</strong></td><td>Field (your own)</td><td>Production monitoring</td></tr></table><div class=\"info-box\"><div class=\"info-title\">üí° Field Data is King</div><p>Lab scores (Lighthouse 100/100) are nice, but Google ranks you based on field data‚Äîreal users over 28 days. Focus on improving field data from Search Console.</p></div><h2>6. Performance Budget Strategy</h2><p>Set limits before building, prevent performance regression.</p><h3>Example Performance Budget</h3><pre>Performance Budget:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Metric                      ‚îÇ Target   ‚îÇ Max    ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ LCP                         ‚îÇ &lt; 2.0s   ‚îÇ 2.5s   ‚îÇ\n‚îÇ INP                         ‚îÇ &lt; 100ms  ‚îÇ 200ms  ‚îÇ\n‚îÇ CLS                         ‚îÇ &lt; 0.05   ‚îÇ 0.1    ‚îÇ\n‚îÇ Total Page Weight           ‚îÇ &lt; 1MB    ‚îÇ 2MB    ‚îÇ\n‚îÇ JavaScript Bundle           ‚îÇ &lt; 200KB  ‚îÇ 300KB  ‚îÇ\n‚îÇ Number of Requests          ‚îÇ &lt; 50     ‚îÇ 75     ‚îÇ\n‚îÇ Time to Interactive         ‚îÇ &lt; 3.5s   ‚îÇ 5s     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</pre><h2>7. The Business Case for Performance</h2><table><tr><th>Company</th><th>Improvement</th><th>Business Impact</th></tr><tr><td>Amazon</td><td>-100ms latency</td><td>+1% revenue</td></tr><tr><td>Walmart</td><td>-1s load time</td><td>+2% conversions</td></tr><tr><td>Pinterest</td><td>-40% wait time</td><td>+15% SEO traffic, +15% signups</td></tr><tr><td>Mobify</td><td>-100ms load time</td><td>+1.11% conversion</td></tr></table><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The 3-Second Rule</div><p>53% of mobile users abandon sites that take longer than 3 seconds to load (Google research). Every second counts. If your LCP is 4 seconds, you're losing half your mobile traffic before they see your product.</p></div><h2>8. Prioritizing Performance Work</h2><h3>High-Impact, Low-Effort Wins</h3><ol><li><strong>Image optimization:</strong> Compress images, convert to WebP (1-2 hours)</li><li><strong>Add dimensions to images:</strong> Fixes CLS (1 hour)</li><li><strong>Enable text compression:</strong> Gzip/Brotli at server level (30 minutes)</li><li><strong>Use a CDN:</strong> Cloudflare free tier works (2 hours setup)</li><li><strong>Defer offscreen images:</strong> Native lazy loading (1 hour)</li></ol><h3>Higher Effort, High Impact</h3><ol><li><strong>Code splitting:</strong> Load only necessary JavaScript (1 week)</li><li><strong>Database optimization:</strong> Faster server response times (ongoing)</li><li><strong>Third-party script audit:</strong> Remove unnecessary analytics/widgets (2 days)</li></ol>",
        questions: [
            { q: "Your Lighthouse score is 98/100, but Search Console shows most users have poor Core Web Vitals. What's happening?", opts: ["Search Console is wrong", "Lighthouse tests in lab conditions (fast connection, powerful device). Field data shows real users on slow connections and old phones‚Äîthat's what matters for SEO.", "Lighthouse score is what Google uses", "Users have bad internet"], correct: 1, explain: "Lab data (Lighthouse) is perfect conditions. Field data (Search Console) is real users. Google ranks based on field data. A 98 lab score means nothing if real users have a poor experience." },
            { q: "Your product page has LCP of 4.5 seconds. Where should you look first?", opts: ["JavaScript bundle size", "The main product image‚Äîcheck file size, format (use WebP), add fetchpriority='high', ensure it's not render-blocked by CSS", "CSS file size", "Server location"], correct: 1, explain: "LCP is usually the hero/product image. Most common issues: huge file size (should be <200KB), wrong format (use WebP), not prioritized. Fix images before optimizing code." },
            { q: "Users report that clicking 'Add to Cart' feels slow, but the action completes in 150ms. What's the issue?", opts: ["150ms is too slow, optimize server", "Poor INP perception‚Äîneed immediate visual feedback (spinner, disable button) even if processing is fast", "Users are wrong, 150ms is fine", "Need faster hosting"], correct: 1, explain: "INP includes perceived responsiveness. Even if backend is fast, users need immediate feedback (button state change, loading indicator). No feedback feels broken." },
            { q: "How do you justify spending 2 weeks on performance optimization to your CEO?", opts: ["Better SEO rankings", "Show data: 1-second improvement = ~7% conversion lift. Calculate revenue impact: if site makes ¬£50k/month, 7% = ¬£3,500/month = ¬£42k/year. 2 weeks of dev time (~¬£8k) pays for itself in 10 weeks.", "Competitors are faster", "Google requires it"], correct: 1, explain: "Business case in revenue terms. Use industry benchmarks (Amazon: 100ms = 1% revenue) or your own A/B test data. Performance improvements pay for themselves quickly." },
            { q: "Your mobile CLS score is 0.25 (poor). What's the most common cause on ecommerce sites?", opts: ["JavaScript errors", "Images and ads loading without reserved space, causing content to shift down as they load", "Slow server", "CSS issues"], correct: 1, explain: "Most CLS comes from images without width/height attributes and ads injected without reserved space. Fix: add dimensions to all images, reserve space for ads/banners." }
        ],
        essay: { q: "Your site's Core Web Vitals are failing (LCP: 4.2s, INP: 350ms, CLS: 0.18). You have one sprint (2 weeks) to improve. How do you prioritize? What wins can you achieve quickly?", guide: "Start with quick wins: 1) Audit main images (product/hero)‚Äîcompress to <200KB, convert to WebP, add fetchpriority='high' (fixes LCP). 2) Add width/height to all images (fixes CLS). 3) Audit and remove unnecessary third-party scripts (improves all metrics). 4) Add loading states to buttons/forms (improves INP perception). Measure with Search Console field data, not just Lighthouse. Calculate business impact: if 1-second improvement = 7% conversion lift, what's the revenue gain? Present to stakeholders in business terms." }
    },
    // DAY 11 - JAVASCRIPT FUNDAMENTALS
    {
        day: 11,
        week: 1,
        title: "JavaScript Fundamentals",
        desc: "The language of web interactivity",
        duration: "55 min",
        coldOpen: "Your dev team proposes rewriting your entire codebase in TypeScript. The project estimate is 4 months. Marketing needs new features next month. How do you evaluate if TypeScript is worth the investment?",
        coldRevisit: "TypeScript adds type safety‚Äîcatching errors at compile time instead of runtime. But it's not all-or-nothing. You can adopt TypeScript incrementally: add it to new code, convert critical files gradually. A 4-month rewrite is unnecessary.",
        content: "<h2>Why This Matters to You</h2><p>JavaScript is the language of web interactivity‚Äîevery button click, form submission, and dynamic update uses JavaScript. As a leader, you don't need to write JavaScript, but understanding how it works helps you evaluate technical decisions: Is this feature complex? Is this timeline realistic? Should we use TypeScript?</p><h2>1. JavaScript Basics: Variables and Data Types</h2><p>JavaScript stores data in variables. There are three ways to declare variables:</p><pre>// const: cannot be reassigned (use this by default)\nconst userName = 'John';\nconst userAge = 30;\n\n// let: can be reassigned (use when value changes)\nlet cartTotal = 0;\ncartTotal = cartTotal + 50;  // Allowed\n\n// var: old style, avoid (causes scoping issues)\nvar oldStyle = 'avoid this';</pre><h3>Data Types</h3><table><tr><th>Type</th><th>Example</th><th>Usage</th></tr><tr><td><strong>String</strong></td><td><code>'Hello'</code> or <code>\"World\"</code></td><td>Text data</td></tr><tr><td><strong>Number</strong></td><td><code>42</code> or <code>3.14</code></td><td>Integers and decimals</td></tr><tr><td><strong>Boolean</strong></td><td><code>true</code> or <code>false</code></td><td>Yes/no, on/off logic</td></tr><tr><td><strong>Array</strong></td><td><code>['apple', 'banana', 'orange']</code></td><td>Lists of items</td></tr><tr><td><strong>Object</strong></td><td><code>{ name: 'John', age: 30 }</code></td><td>Structured data</td></tr><tr><td><strong>null/undefined</strong></td><td><code>null</code> or <code>undefined</code></td><td>Empty or missing values</td></tr></table><h2>2. Functions: Reusable Code Blocks</h2><p>Functions are reusable pieces of code. They take inputs (parameters) and return outputs.</p><pre>// Function declaration\nfunction calculateTotal(price, quantity) {\n  return price * quantity;\n}\n\n// Usage\nconst total = calculateTotal(29.99, 3);\n// total is 89.97\n\n// Arrow function (modern syntax)\nconst calculateDiscount = (price, percent) => {\n  return price * (percent / 100);\n};\n\n// Short arrow function (single expression)\nconst calculateTax = (price) => price * 0.20;</pre><div class=\"info-box\"><div class=\"info-title\">üí° Why Functions Matter</div><p>Functions reduce duplication. If you calculate totals in 5 places, a bug fix requires 5 changes. With a function, fix it once. Functions also make code testable‚Äîyou can verify <code>calculateTotal(10, 3)</code> returns <code>30</code>.</p></div><h2>3. Conditionals: Making Decisions</h2><p>Code needs to make decisions based on data:</p><pre>// if/else statement\nif (cartTotal > 100) {\n  shippingCost = 0;  // Free shipping\n} else if (cartTotal > 50) {\n  shippingCost = 5;  // Reduced shipping\n} else {\n  shippingCost = 10; // Standard shipping\n}\n\n// Ternary operator (shorthand for simple if/else)\nconst shipping = cartTotal > 100 ? 0 : 10;\n\n// Real-world example: checkout validation\nfunction canCheckout(cart, paymentMethod) {\n  if (cart.items.length === 0) {\n    return false;  // Empty cart\n  }\n  if (!paymentMethod) {\n    return false;  // No payment method\n  }\n  return true;  // Can proceed\n}</pre><h2>4. Loops: Processing Lists</h2><p>Loops process arrays of data:</p><pre>const products = [\n  { name: 'Laptop', price: 999 },\n  { name: 'Mouse', price: 29 },\n  { name: 'Keyboard', price: 79 }\n];\n\n// forEach: do something for each item\nproducts.forEach(product => {\n  console.log(product.name);\n});\n\n// map: transform each item into new array\nconst prices = products.map(product => product.price);\n// prices = [999, 29, 79]\n\n// filter: keep only items matching condition\nconst expensive = products.filter(product => product.price > 100);\n// expensive = [{ name: 'Laptop', price: 999 }]\n\n// reduce: calculate single value from array\nconst total = products.reduce((sum, product) => sum + product.price, 0);\n// total = 1107</pre><div class=\"exercise\"><h4>üîß Understanding Business Logic</h4><p>This code calculates bulk discounts:</p><pre>function calculatePrice(quantity, unitPrice) {\n  if (quantity >= 100) return quantity * unitPrice * 0.8;\n  if (quantity >= 50) return quantity * unitPrice * 0.9;\n  return quantity * unitPrice;\n}</pre><p><strong>Question:</strong> What discount does a customer get at 75 units? (Answer: 10% off)</p></div><h2>5. Objects: Structured Data</h2><p>Objects group related data:</p><pre>// Product object\nconst product = {\n  id: 'ABC123',\n  name: 'Wireless Headphones',\n  price: 149.99,\n  inStock: true,\n  categories: ['Electronics', 'Audio'],\n  \n  // Objects can contain functions (methods)\n  applyDiscount: function(percent) {\n    return this.price * (1 - percent / 100);\n  }\n};\n\n// Accessing properties\nconsole.log(product.name);     // 'Wireless Headphones'\nconsole.log(product.price);    // 149.99\n\n// Calling methods\nconst salePrice = product.applyDiscount(20);\n// salePrice = 119.99</pre><h2>6. Asynchronous JavaScript: Handling Delays</h2><p>Many operations take time: API calls, database queries, file uploads. JavaScript handles these asynchronously using Promises and async/await.</p><pre>// Old way: callbacks (messy, hard to read)\nfetchUser(userId, function(user) {\n  fetchOrders(user.id, function(orders) {\n    fetchOrderDetails(orders[0].id, function(details) {\n      // \"Callback hell\" - deeply nested\n    });\n  });\n});\n\n// Modern way: async/await (clean, readable)\nasync function loadCheckoutData() {\n  try {\n    const user = await fetchUser(userId);\n    const orders = await fetchOrders(user.id);\n    const details = await fetchOrderDetails(orders[0].id);\n    return details;\n  } catch (error) {\n    console.error('Failed to load data:', error);\n  }\n}</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è Common Async Mistake</div><p>Forgetting <code>await</code> causes bugs:</p><pre>// Bug: getData() returns Promise, not data\nconst data = getData();  // WRONG\n\n// Correct: await the Promise\nconst data = await getData();  // RIGHT</pre></div><h2>7. Error Handling: try/catch</h2><p>Code can fail. Handle errors gracefully:</p><pre>async function processPayment(paymentData) {\n  try {\n    // Attempt payment\n    const result = await stripeAPI.charge(paymentData);\n    return { success: true, transactionId: result.id };\n  } catch (error) {\n    // Payment failed - log error, show user-friendly message\n    console.error('Payment failed:', error);\n    return { \n      success: false, \n      message: 'Payment declined. Please try another card.' \n    };\n  }\n}</pre><h2>8. JavaScript vs TypeScript</h2><table><tr><th>Aspect</th><th>JavaScript</th><th>TypeScript</th></tr><tr><td><strong>Type Safety</strong></td><td>No compile-time checks</td><td>Catches type errors before runtime</td></tr><tr><td><strong>Learning Curve</strong></td><td>Easier to start</td><td>Requires learning type syntax</td></tr><tr><td><strong>Adoption</strong></td><td>Works immediately</td><td>Can adopt incrementally, file by file</td></tr><tr><td><strong>Build Step</strong></td><td>Runs directly in browser</td><td>Must compile to JavaScript</td></tr><tr><td><strong>IDE Support</strong></td><td>Basic autocomplete</td><td>Excellent autocomplete and refactoring</td></tr></table><h3>TypeScript Example</h3><pre>// JavaScript: no type checking\nfunction calculateTotal(price, quantity) {\n  return price * quantity;\n}\ncalculateTotal('29.99', '3');  // Returns '29.9929.9929.99' (bug!)\n\n// TypeScript: enforces types\nfunction calculateTotal(price: number, quantity: number): number {\n  return price * quantity;\n}\ncalculateTotal('29.99', '3');  // Compile error: strings not allowed</pre><div class=\"info-box\"><div class=\"info-title\">üí° TypeScript Decision Framework</div><p><strong>Adopt TypeScript if:</strong> Large team, complex codebase, frequent refactoring<br><strong>Skip TypeScript if:</strong> Small team, simple site, rapid prototyping<br><strong>Best approach:</strong> Start with JavaScript, add TypeScript to new files as team grows</p></div><h2>9. Common JavaScript Pitfalls</h2><h3>1. Truthy/Falsy Values</h3><pre>// These all evaluate to false:\nif (0) { }          // 0 is falsy\nif ('') { }         // empty string is falsy\nif (null) { }       // null is falsy\nif (undefined) { }  // undefined is falsy\n\n// Problem: this fails if quantity is 0\nif (quantity) {\n  processOrder();   // Won't run if quantity is 0!\n}\n\n// Better: explicit check\nif (quantity !== undefined && quantity !== null) {\n  processOrder();\n}</pre><h3>2. Equality Comparisons</h3><pre>// == does type coercion (usually wrong)\n'5' == 5    // true (string converted to number)\n0 == false  // true\n\n// === checks type and value (use this)\n'5' === 5    // false (different types)\n0 === false  // false</pre><h3>3. Variable Scope</h3><pre>// var has function scope (causes bugs)\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// Prints: 3, 3, 3 (not 0, 1, 2)\n\n// let has block scope (correct)\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// Prints: 0, 1, 2 (as expected)</pre>",
        questions: [
            { q: "Developer says TypeScript will prevent bugs and proposes 4-month rewrite. What should you ask?", opts: ["Approve immediately‚Äîfewer bugs is good", "Ask: Can we adopt TypeScript incrementally for new code and critical files rather than rewriting everything? What specific bugs would this prevent?", "Reject‚ÄîTypeScript is unnecessary", "Wait for TypeScript 2.0"], correct: 1, explain: "TypeScript can be adopted incrementally‚Äîno rewrite needed. Add to new files, convert critical files gradually. Always ask: what specific problems are we solving? Don't rewrite unless necessary." },
            { q: "This code has a bug: `if (quantity) { processOrder(); }` What's wrong?", opts: ["Nothing, it's correct", "If quantity is 0 (a valid order), it's falsy and order won't process. Should use `if (quantity !== null && quantity !== undefined)` instead.", "Should use ==", "processOrder needs await"], correct: 1, explain: "In JavaScript, 0 is falsy. If quantity is 0, the condition fails even though 0 is a valid quantity. Always check explicitly for null/undefined, not truthiness." },
            { q: "Your site has async function that loads product data but sometimes shows 'undefined'. What's likely wrong?", opts: ["Database is slow", "Forgot to use 'await' keyword‚Äîfunction returns Promise, not data. Code tries to use data before it's loaded.", "Need faster server", "JavaScript is broken"], correct: 1, explain: "Common async bug: forgetting await. Without await, you get a Promise object, not the actual data. Always await async operations before using the result." },
            { q: "How do you evaluate if learning TypeScript is worth the team's time?", opts: ["TypeScript is always worth it", "Consider: team size (larger teams benefit more), codebase complexity (complex logic benefits from types), frequency of refactoring (types help). Small teams with simple sites can skip it.", "Never worth it‚ÄîJavaScript is fine", "Flip a coin"], correct: 1, explain: "TypeScript adds value for large teams, complex codebases, and frequent refactoring. Small teams with simple sites get less benefit. Evaluate based on your specific context, not hype." },
            { q: "This code calculates a discount: `const price = product.price * (1 - discount / 100);` What happens if discount is '20' (string) instead of 20 (number)?", opts: ["Works fine‚ÄîJavaScript converts it", "Results in incorrect calculation because string math behaves unexpectedly. TypeScript would catch this at compile time.", "Throws error immediately", "Returns 0"], correct: 1, explain: "JavaScript's type coercion can cause subtle bugs. '20' / 100 works, but unexpected results happen often. TypeScript catches these at compile time, preventing runtime bugs." }
        ],
        essay: { q: "Your dev team wants to adopt TypeScript, estimating 4 months for full migration. How do you evaluate this proposal? What questions do you ask? What alternative approaches might you suggest?", guide: "Ask: What specific bugs or problems will TypeScript solve? Can we quantify the cost of current JavaScript bugs? Can we adopt incrementally (new files only, then convert critical files)? What's the team's TypeScript experience? Alternative: Start with TypeScript on new features only, use JSDoc comments for type hints in existing JavaScript, convert critical/frequently-changed files first. A 4-month full rewrite should be last resort. Calculate: 4 months = ~¬£80k dev cost. Is this justified by bug reduction? Or can incremental adoption achieve 80% of benefits for 20% of cost?" }
    },
    // DAY 12 - DOM & EVENT HANDLING
    {
        day: 12,
        week: 1,
        title: "DOM & Event Handling",
        desc: "How JavaScript interacts with pages",
        duration: "50 min",
        coldOpen: "Customers report 'Add to Cart' sometimes doesn't work‚Äîthey click, nothing happens. Your dev says 'works for me'. QA can't reproduce. What's happening?",
        coldRevisit: "Classic race condition: JavaScript tries to attach event listeners before DOM elements exist. Happens intermittently based on connection speed. Fix: wait for DOM to load before running scripts, or use event delegation.",
        content: "<h2>Why This Matters to You</h2><p>The DOM (Document Object Model) is how JavaScript interacts with web pages‚Äîreading form values, updating text, handling clicks. When customers say 'the button doesn't work sometimes', it's usually a DOM timing issue. Understanding DOM basics helps you diagnose why features work locally but fail in production.</p><h2>1. What is the DOM?</h2><p>The DOM is a tree representation of your HTML that JavaScript can manipulate:</p><pre>&lt;!-- HTML --&gt;\n&lt;div id=\"cart\"&gt;\n  &lt;h2&gt;Shopping Cart&lt;/h2&gt;\n  &lt;button class=\"checkout-btn\"&gt;Checkout&lt;/button&gt;\n&lt;/div&gt;\n\n/* DOM Tree:\ndocument\n  ‚îî‚îÄ div#cart\n       ‚îú‚îÄ h2 \"Shopping Cart\"\n       ‚îî‚îÄ button.checkout-btn \"Checkout\"\n*/</pre><div class=\"info-box\"><div class=\"info-title\">üí° Key Concept</div><p>HTML is the blueprint. DOM is the living structure JavaScript can read and modify. When you click a button, JavaScript finds that button in the DOM and executes code.</p></div><h2>2. Selecting DOM Elements</h2><p>Before you can interact with elements, you need to find them:</p><pre>// Modern selectors (use these)\nconst button = document.querySelector('.checkout-btn');  // First match\nconst allButtons = document.querySelectorAll('.btn');    // All matches\n\n// Old selectors (still common)\nconst element = document.getElementById('cart');         // By ID\nconst items = document.getElementsByClassName('item');   // By class\n\n// Real-world example: find and update cart total\nconst totalElement = document.querySelector('.cart-total');\ntotalElement.textContent = '¬£149.99';</pre><h3>Selector Syntax (CSS-based)</h3><table><tr><th>Selector</th><th>Meaning</th><th>Example</th></tr><tr><td><code>.classname</code></td><td>Class selector</td><td><code>querySelector('.button')</code></td></tr><tr><td><code>#id</code></td><td>ID selector</td><td><code>querySelector('#checkout')</code></td></tr><tr><td><code>element</code></td><td>Tag selector</td><td><code>querySelector('button')</code></td></tr><tr><td><code>[attribute]</code></td><td>Attribute selector</td><td><code>querySelector('[data-id=\"123\"]')</code></td></tr><tr><td>Combinations</td><td>Multiple selectors</td><td><code>querySelector('button.primary')</code></td></tr></table><h2>3. The Race Condition Problem</h2><p>This is the most common DOM bug:</p><pre>&lt;!-- HTML --&gt;\n&lt;script&gt;\n  // This runs IMMEDIATELY - button doesn't exist yet!\n  const button = document.querySelector('.add-to-cart');\n  button.addEventListener('click', addToCart);  // ERROR: button is null\n&lt;/script&gt;\n\n&lt;button class=\"add-to-cart\"&gt;Add to Cart&lt;/button&gt;</pre><h3>Solution 1: Move Script to Bottom</h3><pre>&lt;button class=\"add-to-cart\"&gt;Add to Cart&lt;/button&gt;\n\n&lt;!-- Script runs after button exists --&gt;\n&lt;script&gt;\n  const button = document.querySelector('.add-to-cart');\n  button.addEventListener('click', addToCart);  // Works!\n&lt;/script&gt;</pre><h3>Solution 2: DOMContentLoaded Event</h3><pre>&lt;!-- Script can be anywhere --&gt;\n&lt;script&gt;\n  // Wait for DOM to be fully loaded\n  document.addEventListener('DOMContentLoaded', () => {\n    const button = document.querySelector('.add-to-cart');\n    button.addEventListener('click', addToCart);  // Safe!\n  });\n&lt;/script&gt;</pre><h3>Solution 3: Defer Attribute (Best Practice)</h3><pre>&lt;!-- defer = download in background, execute after DOM ready --&gt;\n&lt;script src=\"app.js\" defer&gt;&lt;/script&gt;\n\n&lt;!-- No DOMContentLoaded needed in app.js --&gt;\n// app.js\nconst button = document.querySelector('.add-to-cart');\nbutton.addEventListener('click', addToCart);</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The 'Works For Me' Problem</div><p>Race conditions are intermittent. Fast connections/computers load scripts before DOM finishes. Slow connections finish DOM before scripts download. If dev tests locally (fast), it works. If user is on 3G (slow), it fails. Always use defer or DOMContentLoaded.</p></div><h2>4. Event Listeners: Responding to User Actions</h2><p>Event listeners attach code to user actions:</p><pre>// Basic click handler\nconst button = document.querySelector('.add-to-cart');\n\nbutton.addEventListener('click', (event) => {\n  event.preventDefault();  // Stop default action (for forms/links)\n  \n  // Get data from button\n  const productId = button.getAttribute('data-product-id');\n  const productName = button.getAttribute('data-product-name');\n  \n  // Add to cart\n  addToCart(productId, productName);\n  \n  // Update UI\n  button.textContent = 'Added!';\n  button.disabled = true;\n});</pre><h3>Common Events</h3><table><tr><th>Event</th><th>When It Fires</th><th>Common Use</th></tr><tr><td><code>click</code></td><td>Element clicked</td><td>Buttons, links</td></tr><tr><td><code>submit</code></td><td>Form submitted</td><td>Checkout, login, search</td></tr><tr><td><code>change</code></td><td>Input value changes</td><td>Dropdowns, checkboxes</td></tr><tr><td><code>input</code></td><td>Text input changes (realtime)</td><td>Search autocomplete</td></tr><tr><td><code>focus</code> / <code>blur</code></td><td>Input gains/loses focus</td><td>Form validation</td></tr><tr><td><code>load</code></td><td>Resource finishes loading</td><td>Images, scripts</td></tr><tr><td><code>scroll</code></td><td>User scrolls</td><td>Infinite scroll, animations</td></tr></table><h2>5. Event Delegation: Handling Dynamic Content</h2><p>Problem: Event listeners don't work on elements added after page load.</p><pre>// WRONG: Listener won't work for future buttons\ndocument.querySelectorAll('.delete-item').forEach(button => {\n  button.addEventListener('click', deleteItem);\n});\n\n// If you add new items dynamically, they won't have listeners!\n</pre><h3>Solution: Event Delegation</h3><pre>// RIGHT: Listen on parent, check if target matches selector\ndocument.querySelector('.cart-items').addEventListener('click', (event) => {\n  // Check if clicked element is a delete button\n  if (event.target.classList.contains('delete-item')) {\n    const itemId = event.target.getAttribute('data-item-id');\n    deleteItem(itemId);\n  }\n});\n\n// Now works for all current AND future delete buttons</pre><div class=\"exercise\"><h4>üîß Debugging Exercise</h4><p>This code doesn't work. Why?</p><pre>&lt;script&gt;\n  const form = document.querySelector('#checkout-form');\n  form.addEventListener('submit', processCheckout);\n&lt;/script&gt;\n\n&lt;form id=\"checkout-form\"&gt;\n  &lt;!-- form fields --&gt;\n&lt;/form&gt;</pre><p><strong>Answer:</strong> Script runs before form exists. Fix: add 'defer' to script tag or wrap in DOMContentLoaded.</p></div><h2>6. Manipulating the DOM</h2><h3>Reading and Writing Content</h3><pre>// Get text content\nconst price = document.querySelector('.price').textContent;  // '¬£29.99'\n\n// Set text content\ndocument.querySelector('.total').textContent = '¬£149.99';\n\n// Get HTML content\nconst html = document.querySelector('.description').innerHTML;\n\n// Set HTML content (be careful with user input - XSS risk!)\ndocument.querySelector('.message').innerHTML = '&lt;strong&gt;Success!&lt;/strong&gt;';</pre><h3>Modifying Classes (Show/Hide, Styling)</h3><pre>const element = document.querySelector('.modal');\n\n// Add class\nelement.classList.add('visible');\n\n// Remove class\nelement.classList.remove('hidden');\n\n// Toggle class (add if absent, remove if present)\nelement.classList.toggle('active');\n\n// Check if class exists\nif (element.classList.contains('disabled')) {\n  // Do something\n}</pre><h3>Reading Form Values</h3><pre>// Get input value\nconst email = document.querySelector('#email').value;\n\n// Get checkbox state\nconst isChecked = document.querySelector('#terms').checked;\n\n// Get selected dropdown option\nconst country = document.querySelector('#country').value;</pre><h2>7. Creating and Removing Elements</h2><pre>// Create new element\nconst newItem = document.createElement('div');\nnewItem.className = 'cart-item';\nnewItem.innerHTML = `\n  &lt;span class=\"product-name\"&gt;Headphones&lt;/span&gt;\n  &lt;span class=\"product-price\"&gt;¬£149.99&lt;/span&gt;\n`;\n\n// Add to DOM\nconst cart = document.querySelector('.cart-items');\ncart.appendChild(newItem);\n\n// Remove element\nconst itemToRemove = document.querySelector('[data-item-id=\"123\"]');\nitemToRemove.remove();</pre><h2>8. Real-World Example: Dynamic Cart</h2><pre>// Add to cart functionality\nfunction setupCart() {\n  // Event delegation for all add-to-cart buttons\n  document.body.addEventListener('click', (event) => {\n    if (event.target.classList.contains('add-to-cart')) {\n      const button = event.target;\n      const productId = button.getAttribute('data-product-id');\n      const productName = button.getAttribute('data-product-name');\n      const productPrice = button.getAttribute('data-product-price');\n      \n      // Add to cart (localStorage for persistence)\n      addToCart({ id: productId, name: productName, price: productPrice });\n      \n      // Visual feedback\n      button.textContent = 'Added!';\n      button.classList.add('added');\n      setTimeout(() => {\n        button.textContent = 'Add to Cart';\n        button.classList.remove('added');\n      }, 2000);\n      \n      // Update cart count\n      updateCartCount();\n    }\n  });\n}\n\nfunction addToCart(product) {\n  const cart = JSON.parse(localStorage.getItem('cart') || '[]');\n  cart.push(product);\n  localStorage.setItem('cart', JSON.stringify(cart));\n}\n\nfunction updateCartCount() {\n  const cart = JSON.parse(localStorage.getItem('cart') || '[]');\n  document.querySelector('.cart-count').textContent = cart.length;\n}\n\n// Initialize when DOM ready\ndocument.addEventListener('DOMContentLoaded', setupCart);</pre>",
        questions: [
            { q: "Customer reports 'Add to Cart' button doesn't work on slow connections, but QA can't reproduce. What's likely the issue?", opts: ["Browser compatibility", "Race condition: JavaScript tries to add event listener before button exists in DOM. Fix: use defer attribute or DOMContentLoaded event.", "Server is slow", "Need to clear cache"], correct: 1, explain: "Classic race condition. On fast connections, DOM loads before script executes. On slow connections, script executes before DOM finishes. Always wait for DOM with defer or DOMContentLoaded." },
            { q: "You dynamically add products to page after initial load. Their 'Add to Cart' buttons don't work. Why?", opts: ["Event listeners were attached to original buttons only, not new ones. Fix: use event delegation‚Äîlisten on parent container instead.", "Need to refresh page", "JavaScript is broken", "Buttons are disabled"], correct: 0, explain: "Event listeners are attached at setup time. New elements don't have listeners. Event delegation solves this: listen on a parent that exists at page load, check if clicked target matches your selector." },
            { q: "What's the difference between textContent and innerHTML?", opts: ["No difference", "textContent sets plain text (safe). innerHTML sets HTML (can execute scripts if user input not sanitized‚ÄîXSS risk).", "innerHTML is faster", "textContent doesn't work on all browsers"], correct: 1, explain: "textContent treats input as plain text (safe). innerHTML parses HTML, which can execute malicious scripts if you insert unsanitized user input. Use textContent unless you specifically need to insert HTML." },
            { q: "This code fails: `const form = document.querySelector('#form'); form.addEventListener(...)` What's the most common cause?", opts: ["querySelector is deprecated", "Script runs before #form element exists in DOM (race condition)", "addEventListener syntax is wrong", "Form doesn't have an ID"], correct: 1, explain: "Most common: script runs before DOM element exists. querySelector returns null, and null.addEventListener throws error. Fix: use defer attribute, DOMContentLoaded, or move script below HTML." },
            { q: "Developer proposes using jQuery to 'make DOM manipulation easier'. Your response?", opts: ["Approve‚ÄîjQuery is essential", "Ask: What specific problems is jQuery solving? Modern vanilla JavaScript (querySelector, classList, fetch) handles most needs. jQuery adds 30KB+ overhead.", "Reject‚ÄîjQuery is obsolete", "Require all third-party libraries"], correct: 1, explain: "jQuery was essential in 2010 when browsers were inconsistent. Modern JavaScript has querySelector, classList, fetch‚Äîmost jQuery use cases covered. Adding 30KB+ library needs justification beyond 'easier'." }
        ],
        essay: { q: "Your checkout flow has intermittent bugs: sometimes form validation doesn't run, sometimes 'Place Order' button doesn't respond. How do you diagnose these DOM timing issues? What questions do you ask your dev team?", guide: "Ask: Where are scripts loaded (in <head>? at bottom?)? Are they using defer or DOMContentLoaded? Test: Throttle network to 3G in Chrome DevTools, does it fail consistently? Check: Open DevTools console, are there 'null' errors? Look for: event listeners attached before DOM ready, event delegation missing for dynamic content. Recommend: Add defer to all scripts, use event delegation for dynamic elements, add error monitoring (Sentry) to catch timing errors in production. Priority: These bugs lose revenue‚Äîcustomers can't checkout. Fix immediately." }
    },
    // DAY 13 - FRONTEND BUILD TOOLS
    {
        day: 13,
        week: 1,
        title: "Frontend Build Tools",
        desc: "Bundlers, transpilers, workflows",
        duration: "50 min",
        coldOpen: "Developer says 'npm install' takes 15 minutes and builds are slow. Your CI pipeline times out. Is this normal? How much should you invest in build optimization?",
        coldRevisit: "15-minute installs are not normal. Likely: corrupted package-lock.json, conflicting dependencies, or inefficient build config. Normal install: 1-3 minutes. Investigate before throwing hardware at the problem.",
        content: "<h2>Why This Matters to You</h2><p>Modern websites aren't just HTML files‚Äîthey require build processes to bundle JavaScript, optimize images, compile CSS. Slow builds waste developer time and delay deploys. Understanding build tools helps you evaluate when 'the build is broken' is an excuse vs. a real problem worth fixing.</p><h2>1. What Are Build Tools?</h2><p>Build tools transform source code into optimized production code:</p><table><tr><th>Tool Type</th><th>Purpose</th><th>Examples</th></tr><tr><td><strong>Package Manager</strong></td><td>Install dependencies</td><td>npm, yarn, pnpm</td></tr><tr><td><strong>Bundler</strong></td><td>Combine many files into few optimized files</td><td>Webpack, Vite, esbuild, Parcel</td></tr><tr><td><strong>Transpiler</strong></td><td>Convert modern JS to older JS for browser compatibility</td><td>Babel</td></tr><tr><td><strong>Task Runner</strong></td><td>Automate repetitive tasks</td><td>npm scripts, Gulp</td></tr><tr><td><strong>Linter</strong></td><td>Check code for errors and style</td><td>ESLint, Prettier</td></tr></table><h2>2. Package Managers: npm, yarn, pnpm</h2><p>Package managers install third-party libraries (dependencies).</p><pre># Install dependencies from package.json\nnpm install\n\n# Add a new dependency\nnpm install react\n\n# Install dev-only dependency (testing, linting)\nnpm install --save-dev eslint</pre><h3>The package.json File</h3><pre>{\n  \"name\": \"my-ecommerce-site\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"dev\": \"vite\",              // npm run dev\n    \"build\": \"vite build\",      // npm run build\n    \"test\": \"jest\"              // npm run test\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",          // Production dependencies\n    \"stripe\": \"^12.0.0\"\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^8.0.0\",          // Development-only\n    \"vite\": \"^4.0.0\"\n  }\n}</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The 15-Minute Install Problem</div><p>If npm install takes more than 5 minutes, something is wrong:</p><ul><li><strong>Corrupted lock file:</strong> Delete package-lock.json and node_modules, reinstall</li><li><strong>Network issues:</strong> Use a registry mirror</li><li><strong>Too many dependencies:</strong> Audit with npm ls --depth=0</li><li><strong>Consider pnpm:</strong> Faster, uses less disk space</li></ul></div><h2>3. Bundlers: From Many Files to One</h2><p>Modern development uses modules‚Äîsmall files, each with one purpose. But browsers load files slowly. Bundlers combine modules into optimized bundles.</p><h3>Without Bundler (Problem)</h3><pre>&lt;!-- Loading many small files = slow --&gt;\n&lt;script src=\"utils.js\"&gt;&lt;/script&gt;\n&lt;script src=\"api.js\"&gt;&lt;/script&gt;\n&lt;script src=\"cart.js\"&gt;&lt;/script&gt;\n&lt;script src=\"checkout.js\"&gt;&lt;/script&gt;\n&lt;!-- 100+ script tags = 100+ HTTP requests --&gt;</pre><h3>With Bundler (Solution)</h3><pre>&lt;!-- One optimized file = fast --&gt;\n&lt;script src=\"bundle.min.js\"&gt;&lt;/script&gt;\n&lt;!-- Contains all code, minified, tree-shaken --&gt;</pre><h3>Modern Bundlers Comparison</h3><table><tr><th>Bundler</th><th>Speed</th><th>Best For</th><th>Learning Curve</th></tr><tr><td><strong>Vite</strong></td><td>‚ö° Very Fast</td><td>New projects, dev speed priority</td><td>Easy</td></tr><tr><td><strong>Webpack</strong></td><td>üê¢ Slower</td><td>Complex configs, mature projects</td><td>Steep</td></tr><tr><td><strong>esbuild</strong></td><td>‚ö°‚ö° Fastest</td><td>Build speed priority</td><td>Medium</td></tr><tr><td><strong>Parcel</strong></td><td>‚ö° Fast</td><td>Zero-config projects</td><td>Easy</td></tr></table><h2>4. Build Process Example</h2><pre># Development mode (fast, unoptimized, includes debugging)\nnpm run dev\n\n# What happens:\n# 1. Start dev server (localhost:3000)\n# 2. Watch files for changes\n# 3. Hot reload on save\n# 4. No optimization (speed priority)\n\n# Production build (slow, optimized)\nnpm run build\n\n# What happens:\n# 1. Bundle all JavaScript into app.js\n# 2. Minify code (remove whitespace, shorten variables)\n# 3. Tree-shake (remove unused code)\n# 4. Optimize images\n# 5. Generate source maps for debugging\n# 6. Output to dist/ folder\n</pre><div class=\"info-box\"><div class=\"info-title\">üí° Dev vs. Prod Builds</div><p><strong>Development:</strong> Fast rebuilds, readable code, detailed errors<br><strong>Production:</strong> Optimized size, fast loading, minified code<br><br>Never deploy dev builds‚Äîthey're 10x larger and expose debug info.</p></div><h2>5. Common Build Problems</h2><table><tr><th>Problem</th><th>Symptom</th><th>Solution</th></tr><tr><td><strong>Slow builds</strong></td><td>npm run build takes 10+ minutes</td><td>Use faster bundler (Vite/esbuild), reduce dependencies, check for circular imports</td></tr><tr><td><strong>Out of memory</strong></td><td>JavaScript heap out of memory</td><td>Increase Node memory: NODE_OPTIONS=--max-old-space-size=4096</td></tr><tr><td><strong>Dependency conflicts</strong></td><td>npm install fails with ERESOLVE</td><td>Check for incompatible versions, use npm install --legacy-peer-deps as workaround</td></tr><tr><td><strong>CI timeouts</strong></td><td>Build times out in GitHub Actions</td><td>Cache node_modules, use pnpm, optimize build config</td></tr></table><h2>6. Code Splitting: Load Only What's Needed</h2><p>Don't send all code to all users. Split by route:</p><pre>// Bad: one huge bundle with everything\nimport Home from './pages/Home';\nimport Checkout from './pages/Checkout';\nimport Admin from './pages/Admin';\n\n// Good: code splitting with dynamic imports\nconst Home = lazy(() => import('./pages/Home'));\nconst Checkout = lazy(() => import('./pages/Checkout'));\nconst Admin = lazy(() => import('./pages/Admin'));\n\n// Result:\n// - Home page users download only Home code\n// - Checkout users download only Checkout code\n// - Admin code never sent to regular users</pre><h3>Bundle Size Budget</h3><pre>Good bundle sizes:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ File                 ‚îÇ Target    ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Main JS bundle       ‚îÇ < 200 KB  ‚îÇ\n‚îÇ CSS bundle           ‚îÇ < 50 KB   ‚îÇ\n‚îÇ Vendor/libraries     ‚îÇ < 150 KB  ‚îÇ\n‚îÇ Total initial load   ‚îÇ < 400 KB  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</pre><h2>7. Transpilation: Modern Code for Old Browsers</h2><p>You write modern JavaScript, but some users have old browsers. Transpilers convert modern code to compatible code:</p><pre>// Modern JavaScript (you write)\nconst products = items.filter(item => item.price > 100);\n\n// Transpiled for old browsers (Babel outputs)\nvar products = items.filter(function(item) {\n  return item.price > 100;\n});</pre><h3>When to Transpile</h3><ul><li><strong>Target modern browsers only (2022+)?</strong> No transpilation needed</li><li><strong>Support older browsers?</strong> Use Babel with appropriate presets</li><li><strong>Check your analytics:</strong> If <2% use old browsers, consider dropping support</li></ul><h2>8. CI/CD Build Optimization</h2><pre># Slow CI build (problem)\nname: Build\nsteps:\n  - npm install          # 5 minutes\n  - npm run build        # 10 minutes\n  - npm test             # 8 minutes\n# Total: 23 minutes per deploy\n\n# Optimized CI build (solution)\nname: Build\nsteps:\n  - uses: actions/cache@v3\n    with:\n      path: ~/.pnpm-store\n      key: ${{ runner.os }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}\n  - pnpm install         # 30 seconds (cached)\n  - pnpm build           # 2 minutes (using Vite)\n  - pnpm test            # 3 minutes\n# Total: 5.5 minutes per deploy</pre><div class=\"exercise\"><h4>üîß Build Audit Exercise</h4><ol><li>Run npm run build and time it. Target: <3 minutes</li><li>Check bundle size: ls -lh dist/*.js. Target: <200KB main bundle</li><li>Run npm ls --depth=0 to see all dependencies. Are they all necessary?</li></ol></div>",
        questions: [
            { q: "Developer says npm install takes 15 minutes. What should you investigate first?", opts: ["Buy faster servers", "Check if package-lock.json is corrupted, look for dependency conflicts, consider switching to pnpm. 15 minutes is not normal‚Äîtypical install should be 1-3 minutes.", "It's normal for large projects", "Upgrade npm"], correct: 1, explain: "15-minute installs indicate a problem: corrupted lock file, network issues, or inefficient package manager. Normal installs are 1-3 minutes. Investigate before adding resources." },
            { q: "Your main JavaScript bundle is 2.5MB. PageSpeed Insights says this is 'blocking'. What's the issue?", opts: ["PageSpeed is wrong", "Bundle is too large‚Äîusers download 2.5MB before page becomes interactive. Need code splitting, tree shaking, and lazy loading. Target: <200KB main bundle.", "Need faster CDN", "Compress the bundle"], correct: 1, explain: "2.5MB is huge‚Äîusers on 3G wait 20+ seconds. Modern best practice: <200KB initial bundle. Use code splitting to load only needed code, lazy load routes, tree-shake unused dependencies." },
            { q: "What's the difference between dependencies and devDependencies in package.json?", opts: ["No real difference", "dependencies = needed in production (React, Stripe). devDependencies = only for development (testing, linting). This affects production bundle size.", "devDependencies are optional", "dependencies install first"], correct: 1, explain: "dependencies ship to production. devDependencies are build-time only (tests, linters). Misclassifying adds unnecessary weight to production bundles. Always use --save-dev for build tools." },
            { q: "Build works locally but fails in CI with 'JavaScript heap out of memory'. What's happening?", opts: ["CI is broken", "Build requires more memory than CI provides. Fix: increase Node memory limit (NODE_OPTIONS=--max-old-space-size=4096) or optimize build.", "Need to upgrade CI plan", "Restart CI"], correct: 1, explain: "Local machines often have more RAM than CI. Node defaults to ~1.5GB heap. Large builds need more. Fix: increase limit or optimize (reduce dependencies, improve build config)." },
            { q: "Developer proposes migrating from Webpack to Vite, estimating 2 weeks. How do you evaluate?", opts: ["Approve‚ÄîVite is modern", "Ask: what's the current pain? (slow builds?) What's the benefit? (faster dev server, quicker builds?) Is 2 weeks justified? Can we test on one feature first?", "Reject‚ÄîWebpack is fine", "Require 6-month plan"], correct: 1, explain: "Evaluate migrations by specific problems and measurable benefits. If builds take 15 min and Vite reduces to 2 min, calculate dev time saved. Test on small feature before full migration." }
        ],
        essay: { q: "Your CI builds time out after 30 minutes. Local builds take 12 minutes. How do you diagnose and fix this? What's the cost/benefit of build optimization?", guide: "Diagnose: Profile build (webpack-bundle-analyzer), check dependency count (npm ls), compare CI vs local (caching? slower hardware?). Common causes: no caching (every build reinstalls), slow bundler (Webpack), huge dependencies. Fixes: Enable CI caching (pnpm + cache action), switch to faster bundler (Vite: 10x faster), audit dependencies (remove unused), code splitting. Cost/benefit: If 20 devs deploy 5x/day, 12-minute builds = 1000 minutes/day wasted. Reducing to 3 minutes saves ¬£300+/day in dev time. 1-week optimization investment pays for itself in 1 month." }
    },

    // DAY 14 - FRONTEND FRAMEWORKS
    {
        day: 14,
        week: 1,
        title: "Frontend Frameworks",
        desc: "React, Vue, Angular - when to use",
        duration: "55 min",
        coldOpen: "Your dev team says your jQuery codebase is unmaintainable and wants to rewrite in React. Estimate: 6 months. Marketing needs features next quarter. How do you evaluate if a framework migration is justified?",
        coldRevisit: "Framework migrations are expensive (6 months = ¬£300k+ dev cost) and risky. Always ask: what specific problems are we solving? Can we adopt incrementally? Modern frameworks solve real problems (state management, component reuse), but full rewrites rarely deliver expected value on time.",
        content: "<h2>Why This Matters to You</h2><p>Frontend frameworks (React, Vue, Angular) are among the most expensive technical decisions you'll make. A framework rewrite can cost ¬£300k+ and take a year. Understanding what problems frameworks solve‚Äîand when they're overkill‚Äîhelps you evaluate proposals critically and avoid expensive mistakes.</p><h2>1. What Problem Do Frameworks Solve?</h2><p>Before frameworks, building interactive sites meant manually manipulating the DOM‚Äîtedious and error-prone:</p><pre>// Without framework: manual DOM updates (messy)\nfunction updateCart() {\n  const cart = getCart();\n  \n  // Update count\n  document.querySelector('.cart-count').textContent = cart.length;\n  \n  // Update total\n  const total = cart.reduce((sum, item) => sum + item.price, 0);\n  document.querySelector('.cart-total').textContent = '$' + total;\n  \n  // Update item list\n  const listHTML = cart.map(item => \n    `<div>${item.name} - $${item.price}</div>`\n  ).join('');\n  document.querySelector('.cart-items').innerHTML = listHTML;\n  \n  // If data changes, manually call updateCart() everywhere\n}\n\n// With framework: declarative UI (clean)\nfunction Cart({ items }) {\n  const total = items.reduce((sum, item) => sum + item.price, 0);\n  \n  return (\n    <div>\n      <div>Items: {items.length}</div>\n      <div>Total: ${total}</div>\n      <div>\n        {items.map(item => (\n          <div key={item.id}>{item.name} - ${item.price}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n// UI automatically updates when items change</pre><div class=\"info-box\"><div class=\"info-title\">üí° The Core Benefit</div><p>Frameworks provide <strong>declarative UI</strong>: describe what the UI should look like based on data. Framework handles DOM updates automatically. No manual querySelector or innerHTML.</p></div><h2>2. The Big Three Frameworks</h2><table><tr><th>Framework</th><th>Created By</th><th>Philosophy</th><th>Best For</th><th>Market Share</th></tr><tr><td><strong>React</strong></td><td>Meta (Facebook)</td><td>Library, not framework. Flexible, large ecosystem</td><td>Complex apps, large teams, hiring availability</td><td>~40%</td></tr><tr><td><strong>Vue</strong></td><td>Evan You (independent)</td><td>Progressive framework. Start simple, add features as needed</td><td>Incremental adoption, smaller teams</td><td>~18%</td></tr><tr><td><strong>Angular</strong></td><td>Google</td><td>Full framework. Opinionated, batteries-included</td><td>Large enterprise apps, TypeScript-first</td><td>~15%</td></tr></table><h2>3. React Fundamentals</h2><p>React is a library for building user interfaces with components:</p><pre>// Component: reusable UI piece\nfunction ProductCard({ product }) {\n  const [inCart, setInCart] = useState(false);\n  \n  const handleAddToCart = () => {\n    addToCart(product.id);\n    setInCart(true);\n  };\n  \n  return (\n    <div className=\"product-card\">\n      <img src={product.image} alt={product.name} />\n      <h3>{product.name}</h3>\n      <p>${product.price}</p>\n      <button \n        onClick={handleAddToCart}\n        disabled={inCart}\n      >\n        {inCart ? 'Added' : 'Add to Cart'}\n      </button>\n    </div>\n  );\n}\n\n// Usage: render multiple products\n<div className=\"product-grid\">\n  {products.map(product => (\n    <ProductCard key={product.id} product={product} />\n  ))}\n</div></pre><h3>React Concepts</h3><table><tr><th>Concept</th><th>Purpose</th><th>Example</th></tr><tr><td><strong>Components</strong></td><td>Reusable UI pieces</td><td><code>&lt;ProductCard /&gt;</code>, <code>&lt;Header /&gt;</code></td></tr><tr><td><strong>Props</strong></td><td>Pass data to components</td><td><code>&lt;ProductCard product={product} /&gt;</code></td></tr><tr><td><strong>State</strong></td><td>Component's internal data</td><td><code>const [count, setCount] = useState(0)</code></td></tr><tr><td><strong>Hooks</strong></td><td>Add features to components</td><td><code>useState</code>, <code>useEffect</code></td></tr><tr><td><strong>JSX</strong></td><td>HTML-like syntax in JavaScript</td><td><code>&lt;div&gt;Hello&lt;/div&gt;</code></td></tr></table><h2>4. When to Use a Framework</h2><h3>Good Reasons to Use a Framework</h3><ul><li><strong>Complex state:</strong> Many interdependent UI pieces (filters, cart, checkout)</li><li><strong>Reusable components:</strong> Same UI patterns across many pages</li><li><strong>Real-time updates:</strong> UI changes frequently based on user actions</li><li><strong>Team collaboration:</strong> Component model helps teams work in parallel</li><li><strong>Mobile app planned:</strong> React Native shares code with React web</li></ul><h3>Bad Reasons to Use a Framework</h3><ul><li><strong>'It's modern':</strong> Tech hype isn't a business reason</li><li><strong>'Easier to hire':</strong> Good developers adapt‚Äîhire for fundamentals</li><li><strong>'jQuery is old':</strong> Old doesn't mean wrong‚Äîif it works, it works</li><li><strong>'We need to refactor anyway':</strong> Refactor doesn't require rewrite</li></ul><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The Rewrite Trap</div><p>Framework rewrites typically:<br>‚Ä¢ Take 2-3x longer than estimated<br>‚Ä¢ Introduce new bugs<br>‚Ä¢ Pause feature development<br>‚Ä¢ Cost ¬£300k+ for medium-sized sites<br><br>Incremental adoption is almost always better than big-bang rewrites.</p></div><h2>5. Incremental Adoption Strategy</h2><p>Don't rewrite everything‚Äîadopt incrementally:</p><pre>Phase 1: New features only\n- Keep existing jQuery code\n- Build new features in React\n- Isolate: mount React components in specific divs\n- Timeline: immediate\n\nPhase 2: High-value pages\n- Convert highest-traffic pages (product, checkout)\n- Measure: performance, conversion improvements\n- Timeline: 3-6 months\n\nPhase 3: Complete migration (optional)\n- Only if Phase 1-2 show clear value\n- Convert remaining pages\n- Timeline: 6-12 months</pre><h3>Mounting React in Existing Site</h3><pre>&lt;!-- Existing jQuery site --&gt;\n&lt;div id=\"legacy-content\"&gt;\n  &lt;!-- Existing code stays --&gt;\n&lt;/div&gt;\n\n&lt;!-- New React component --&gt;\n&lt;div id=\"react-root\"&gt;&lt;/div&gt;\n&lt;script&gt;\n  // Mount React in specific container\n  ReactDOM.render(&lt;NewFeature /&gt;, document.getElementById('react-root'));\n&lt;/script&gt;\n\n&lt;!-- Both coexist peacefully --&gt;</pre><h2>6. Framework Decision Matrix</h2><table><tr><th>Your Situation</th><th>Recommendation</th><th>Why</th></tr><tr><td>Simple marketing site, 10 pages</td><td>No framework‚Äîvanilla JS or jQuery</td><td>Framework overhead not justified</td></tr><tr><td>Product catalog, some interactivity</td><td>Consider Vue (incremental)</td><td>Easy to adopt gradually</td></tr><tr><td>Complex ecommerce, custom checkout</td><td>React or Vue</td><td>State management benefits clear</td></tr><tr><td>Large team, enterprise</td><td>React (hiring) or Angular (structure)</td><td>Ecosystem and talent pool</td></tr><tr><td>Existing jQuery, working well</td><td>Keep it, add framework incrementally if needed</td><td>Working code has value</td></tr></table><h2>7. The Build vs. Buy Decision</h2><p>Before building custom with a framework, consider platforms:</p><table><tr><th>Option</th><th>Pros</th><th>Cons</th><th>Cost</th></tr><tr><td><strong>Shopify/Magento</strong></td><td>Fast launch, maintained</td><td>Less customization</td><td>¬£100-500/mo</td></tr><tr><td><strong>Headless CMS + React</strong></td><td>Flexibility, modern stack</td><td>More complex, need devs</td><td>¬£50k-150k build</td></tr><tr><td><strong>Custom framework app</strong></td><td>Complete control</td><td>Expensive, slow, maintenance burden</td><td>¬£150k-500k build</td></tr></table><div class=\"exercise\"><h4>üîß Framework Evaluation Exercise</h4><p>Your dev team proposes React migration. Ask:</p><ol><li>What specific problems are we solving? (Be specific‚Äînot 'maintainability')</li><li>Can we solve these without a full rewrite?</li><li>Can we adopt incrementally on one page first?</li><li>What's the cost? (Dev months √ó ¬£8k/mo)</li><li>What's the risk if we don't do this?</li></ol></div><h2>8. Framework Performance Considerations</h2><p>Frameworks add weight. Make sure the benefits justify the cost:</p><pre>Bundle Size Comparison:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Approach            ‚îÇ JS Size     ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Vanilla JS          ‚îÇ 10-50 KB    ‚îÇ\n‚îÇ jQuery              ‚îÇ 30 KB       ‚îÇ\n‚îÇ Vue                 ‚îÇ 40 KB       ‚îÇ\n‚îÇ React               ‚îÇ 45 KB       ‚îÇ\n‚îÇ Angular             ‚îÇ 70 KB       ‚îÇ\n‚îÇ React + Router      ‚îÇ 90 KB       ‚îÇ\n‚îÇ Full React app      ‚îÇ 200+ KB     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nFor simple sites: Framework overhead not justified\nFor complex apps: Framework benefits outweigh cost</pre>",
        questions: [
            { q: "Dev team wants to rewrite your working jQuery site in React. Estimate: 6 months. Your response?", opts: ["Approve‚ÄîReact is modern", "Ask: What specific problems are we solving? Can we adopt React incrementally for new features instead of rewriting? What's the business case for ¬£300k+ investment?", "Reject‚ÄîjQuery works fine", "Hire React consultants"], correct: 1, explain: "Working code has value. React rewrites are expensive (6 months = ¬£300k+ dev cost) and risky. Always ask for specific problems and consider incremental adoption‚Äîbuild new features in React while keeping existing code." },
            { q: "Your site is 10 pages with light interactivity. Developer insists you need React. Your evaluation?", opts: ["Agree‚ÄîReact is industry standard", "For simple sites, framework overhead (45KB+ base, build complexity) isn't justified. Vanilla JavaScript or lightweight library sufficient. Frameworks make sense for complex state management.", "Compromise‚Äîuse Vue instead", "Hire more developers"], correct: 1, explain: "Frameworks solve specific problems: complex state, component reuse, frequent updates. Simple sites don't have these problems. Adding 45KB+ framework for light interactivity is overengineering." },
            { q: "What's the main benefit of component-based frameworks like React?", opts: ["Faster performance", "Reusable UI components with encapsulated logic. Build once (ProductCard), use everywhere. Changes in one place update all instances.", "Better SEO", "Easier to learn"], correct: 1, explain: "Components provide reusability and maintainability. Build ProductCard once with all logic, reuse across site. Change price formatting in one place, updates everywhere. Reduces duplication and bugs." },
            { q: "How should you approach migrating from jQuery to React?", opts: ["6-month full rewrite", "Incremental: 1) Build new features in React, 2) Convert high-value pages, 3) Measure success, 4) Continue only if clear benefit. Both can coexist.", "Stay with jQuery forever", "Rebuild in Vue instead"], correct: 1, explain: "Incremental adoption is safer and cheaper. Mount React in specific containers while keeping existing code. Convert high-traffic pages first, measure improvements. Full rewrite is last resort." },
            { q: "Which signal suggests you might benefit from a framework?", opts: ["Competitors use frameworks", "Complex interdependent state: filters update products, products update cart, cart updates totals‚Äîlots of DOM manipulation in multiple places. Framework's reactive state helps.", "Your jQuery code is old", "Developers want to learn React"], correct: 1, explain: "Frameworks excel at managing complex state. If you're manually syncing many DOM elements when data changes, framework's reactive model (data changes ‚Üí UI updates automatically) simplifies code." }
        ],
        essay: { q: "Your dev team proposes a 6-month React migration from your current jQuery site. The site works but 'isn't modern'. How do you evaluate this proposal? What questions do you ask? What alternative approaches might be better?", guide: "Evaluate: 1) What specific problems exist? (Not 'jQuery is old'‚Äîwhat breaks? what's slow to build?) 2) Cost: 6 months = 3 devs √ó ¬£8k/mo = ¬£144k minimum. What's the ROI? 3) Risk: Feature development pauses, new bugs introduced, timelines slip 2-3x. 4) Alternatives: Can we solve problems without rewrite? Can we adopt React incrementally (new features only)? Can we refactor jQuery incrementally? Questions: Show me the 5 most painful code areas. Can we fix these specifically? Have you built with React before (learning curve)? What if we try React on one new feature first? Recommendation: Almost never approve big-bang rewrites. Start with one new feature in React, measure success (dev velocity, bugs, performance), then decide. Working code has value‚Äîpreserve it." }
    },
    // DAY 15 - SERVER-SIDE RENDERING
    {
        day: 15,
        week: 2,
        title: "Server-Side Rendering",
        desc: "SSR, SSG, ISR explained",
        duration: "50 min",
        coldOpen: "Your SEO agency says your product pages aren't being indexed properly by Google. They recommend 'server-side rendering'. Your React site currently uses client-side rendering. Is this a real problem? What's the investment required?",
        coldRevisit: "Real problem. Client-side rendering sends empty HTML‚ÄîJavaScript fills content after load. Search bots may not wait. SSR sends complete HTML immediately. Options: Next.js (React SSR framework), static site generation, or pre-rendering service. Investment: 2-4 weeks for Next.js migration.",
        content: "<h2>Why This Matters to You</h2><p>Server-side rendering (SSR) affects SEO, performance, and user experience. The wrong rendering strategy can hide your products from Google, slow down page loads, and cost you traffic. Understanding SSR helps you evaluate technical proposals that claim to 'fix SEO' or 'improve performance'.</p><h2>1. The Three Rendering Strategies</h2><table><tr><th>Strategy</th><th>How It Works</th><th>Pros</th><th>Cons</th></tr><tr><td><strong>CSR</strong><br>(Client-Side Rendering)</td><td>Send empty HTML, JavaScript fills content</td><td>Simple to build, cheap hosting</td><td>Slow initial load, SEO challenges</td></tr><tr><td><strong>SSR</strong><br>(Server-Side Rendering)</td><td>Server generates full HTML for each request</td><td>Fast initial load, SEO-friendly</td><td>Requires server, more complex</td></tr><tr><td><strong>SSG</strong><br>(Static Site Generation)</td><td>Pre-generate HTML at build time</td><td>Fastest, cheap hosting (CDN)</td><td>Only for content that doesn't change often</td></tr></table><h2>2. Client-Side Rendering (CSR) Problem</h2><p>This is what most React/Vue apps do by default:</p><pre>&lt;!-- What Google sees (empty HTML) --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;My Shop&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=\"root\"&gt;&lt;/div&gt;  &lt;!-- Empty! --&gt;\n  &lt;script src=\"app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n&lt;!-- JavaScript fills content AFTER load --&gt;\n&lt;!-- If Google doesn't wait, it sees nothing --&gt;</pre><h3>CSR Timeline</h3><pre>User visits page:\n1. [0ms] Request HTML\n2. [200ms] Receive empty HTML\n3. [200ms] Download app.js (200KB)\n4. [300ms] Execute JavaScript\n5. [500ms] Fetch product data from API\n6. [700ms] Render content\n\nUser sees content at 700ms\nGoogle may not wait this long</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The SEO Impact</div><p>Google can execute JavaScript, but:<br>‚Ä¢ It's slower and less reliable<br>‚Ä¢ May not wait for API calls<br>‚Ä¢ Indexing is delayed<br>‚Ä¢ Social media previews don't work (Facebook/Twitter don't run JavaScript)<br><br>For ecommerce: Products not indexed = products not found = lost sales.</p></div><h2>3. Server-Side Rendering (SSR)</h2><p>Server generates complete HTML for each request:</p><pre>&lt;!-- What Google sees (complete HTML) --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;Wireless Headphones - $149&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=\"root\"&gt;\n    &lt;h1&gt;Wireless Headphones&lt;/h1&gt;\n    &lt;p&gt;Price: $149.99&lt;/p&gt;\n    &lt;button&gt;Add to Cart&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=\"app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n&lt;!-- Content visible immediately, JavaScript adds interactivity --&gt;</pre><h3>SSR Timeline</h3><pre>User visits page:\n1. [0ms] Request HTML\n2. [100ms] Server fetches product data\n3. [200ms] Server renders HTML\n4. [300ms] User receives complete HTML ‚Üí content visible!\n5. [500ms] JavaScript downloads and \"hydrates\" (adds interactivity)\n\nUser sees content at 300ms (2x faster)\nGoogle sees full content immediately</pre><h2>4. Static Site Generation (SSG)</h2><p>Pre-generate HTML at build time (fastest):</p><pre># Build process (runs once)\n1. Fetch all products from database\n2. Generate HTML file for each product\n3. Output: /products/headphones.html, /products/laptop.html, etc.\n4. Deploy to CDN\n\n# User request (instant)\n1. User requests /products/headphones.html\n2. CDN serves pre-built file immediately\n3. No server rendering, no database query\n\nResult: 50-100ms response time</pre><h3>When to Use SSG</h3><ul><li><strong>Good for:</strong> Marketing pages, blog posts, product catalogs (if updated infrequently)</li><li><strong>Not good for:</strong> Personalized content, real-time data, user dashboards</li></ul><div class=\"info-box\"><div class=\"info-title\">üí° Hybrid Approach: ISR</div><p><strong>Incremental Static Regeneration (ISR):</strong> Pre-generate pages, but regenerate them periodically or on-demand. Best of both worlds:<br>‚Ä¢ Fast like SSG (serve from CDN)<br>‚Ä¢ Fresh like SSR (regenerate every 60 seconds)<br>‚Ä¢ Example: Product pages regenerate when inventory changes</p></div><h2>5. Next.js: The Popular SSR Framework</h2><p>Next.js (React) makes SSR easy:</p><pre>// pages/products/[id].js\nexport default function Product({ product }) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{product.name}&lt;/h1&gt;\n      &lt;p&gt;Price: ${product.price}&lt;/p&gt;\n      &lt;button&gt;Add to Cart&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\n// This runs on the SERVER for each request\nexport async function getServerSideProps({ params }) {\n  const product = await fetch(`/api/products/${params.id}`);\n  return { props: { product } };\n}\n\n// Or use SSG (build time)\nexport async function getStaticProps({ params }) {\n  const product = await fetch(`/api/products/${params.id}`);\n  return { \n    props: { product },\n    revalidate: 60 // ISR: regenerate every 60 seconds\n  };\n}</pre><h2>6. SSR Decision Matrix</h2><table><tr><th>Page Type</th><th>Strategy</th><th>Why</th></tr><tr><td>Marketing homepage</td><td>SSG</td><td>Rarely changes, needs fast load</td></tr><tr><td>Product catalog</td><td>SSG + ISR</td><td>Frequent but not real-time changes</td></tr><tr><td>Product detail page</td><td>SSG + ISR</td><td>Need SEO, can regenerate periodically</td></tr><tr><td>Shopping cart</td><td>CSR</td><td>User-specific, no SEO needed</td></tr><tr><td>User dashboard</td><td>CSR</td><td>Behind login, personalized</td></tr><tr><td>Checkout</td><td>SSR or CSR</td><td>Behind login, but needs reliability</td></tr><tr><td>Search results</td><td>SSR</td><td>Dynamic queries, need SEO</td></tr></table><h2>7. Migration Path: CSR ‚Üí SSR</h2><pre>Phase 1: Assess (1 week)\n- Which pages need SEO? (Product pages: yes. Dashboard: no.)\n- Current indexing issues?\n- Check Google Search Console for crawl errors\n\nPhase 2: Pilot (2-3 weeks)\n- Implement SSR for highest-value pages (top 20 products)\n- Use Next.js or similar framework\n- Measure: indexing speed, SEO rankings, page load time\n\nPhase 3: Rollout (4-8 weeks)\n- Migrate remaining public pages\n- Keep CSR for authenticated pages\n- Monitor Core Web Vitals\n\nPhase 4: Optimize\n- Implement ISR for product pages\n- Use CDN caching\n- Monitor server costs (SSR requires compute)</pre><h2>8. Cost Implications</h2><table><tr><th>Strategy</th><th>Hosting Cost</th><th>Dev Complexity</th><th>Example Monthly Cost</th></tr><tr><td><strong>CSR</strong></td><td>Very low (static hosting)</td><td>Simple</td><td>$5-20 (Netlify/Vercel)</td></tr><tr><td><strong>SSG</strong></td><td>Low (CDN)</td><td>Medium</td><td>$20-100</td></tr><tr><td><strong>SSR</strong></td><td>Medium-High (compute)</td><td>Complex</td><td>$100-500+ (scales with traffic)</td></tr><tr><td><strong>ISR</strong></td><td>Medium (CDN + compute)</td><td>Medium</td><td>$50-200</td></tr></table><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The Server Cost Surprise</div><p>SSR requires servers to run for every request. If you have 100k daily visitors:<br>‚Ä¢ CSR: $20/month (static files)<br>‚Ä¢ SSR: $500+/month (compute for 100k renders)<br><br>Use ISR or SSG where possible to reduce costs.</p></div><h2>9. Debugging SSR Issues</h2><pre>Common SSR problems:\n\n1. \"window is not defined\"\n   Problem: Browser-only code runs on server\n   Fix: Check if window exists before using:\n        if (typeof window !== 'undefined') { ... }\n\n2. Hydration mismatch\n   Problem: Server HTML doesn't match client HTML\n   Fix: Ensure server and client render same output\n\n3. Slow server rendering\n   Problem: Database queries slow down HTML generation\n   Fix: Optimize queries, add caching, use ISR instead\n\n4. Increased server costs\n   Problem: SSR compute is expensive\n   Fix: Use SSG/ISR where possible, add caching layers</pre>",
        questions: [
            { q: "Your SEO agency says your React site has indexing issues because it's client-side rendered. Is this a real problem?", opts: ["No‚ÄîGoogle runs JavaScript now", "Yes‚ÄîCSR sends empty HTML. Google may index it, but slowly and unreliably. Social media previews don't work. SSR or SSG sends complete HTML immediately.", "Only a problem for old sites", "Just add more meta tags"], correct: 1, explain: "Real problem. While Google can execute JavaScript, it's slower and less reliable than getting complete HTML. Social previews (Facebook, Twitter) don't run JavaScript at all. SSR fixes this." },
            { q: "What's the difference between SSR and SSG?", opts: ["No difference", "SSR generates HTML for each request (dynamic, server required). SSG pre-generates HTML at build time (fast, CDN-friendly, but static). ISR combines both.", "SSR is faster", "SSG is for blogs only"], correct: 1, explain: "SSR: server generates HTML per request (good for dynamic content, requires compute). SSG: generate all pages at build time (fastest, cheapest, but content is static until next build). ISR: SSG with periodic regeneration." },
            { q: "Your product catalog has 10,000 products. Which rendering strategy makes sense?", opts: ["CSR for speed", "SSG + ISR: Pre-generate all product pages at build time, regenerate when inventory changes. Serves from CDN (fast), stays fresh (SEO), low cost.", "SSR for every request", "Generate pages manually"], correct: 1, explain: "SSG with ISR is ideal: pre-generate all pages (one-time build cost), serve from CDN (fast + cheap), regenerate periodically or on inventory updates (fresh content). SSR would be expensive at scale." },
            { q: "Developer proposes migrating to Next.js for SSR. Timeline: 6 weeks. How do you evaluate?", opts: ["Approve if SEO is suffering", "Ask: Which pages need SEO? (public product pages: yes; dashboard/cart: no). Can we migrate incrementally (public pages first)? What's the hosting cost increase? Pilot on top 20 products first?", "Reject‚Äîtoo expensive", "Require 3-month timeline"], correct: 1, explain: "Don't migrate everything. Identify pages that need SEO (public content), keep CSR for authenticated pages. Pilot on high-value pages, measure results, then scale. Incremental adoption reduces risk." },
            { q: "After implementing SSR, your hosting costs increased from $20 to $400/month. Why?", opts: ["Vendor is overcharging", "SSR requires compute for every page render. Unlike CSR (static files) or SSG (pre-built), SSR runs code per request. Consider ISR to reduce costs‚Äîpre-generate pages, regenerate periodically.", "SSR is more expensive technology", "Configuration error"], correct: 1, explain: "SSR is compute-intensive‚Äîserver runs code for every request. CSR serves static files ($20/mo). SSR requires servers ($400/mo+). ISR reduces cost: pre-generate pages, serve from CDN, regenerate periodically." }
        ],
        essay: { q: "Your SEO agency says your product pages aren't ranking well and recommends 'server-side rendering'. Your React site uses CSR. How do you evaluate if this investment is justified? What questions do you ask? What's your migration strategy?", guide: "Evaluate SEO impact: Check Google Search Console‚Äîare pages indexed? How long does indexing take? Are product pages appearing in search? Check social shares‚Äîdo previews work? Questions for dev: Can we use SSG/ISR instead of full SSR (cheaper)? Can we migrate incrementally? What's the cost (development + hosting)? Strategy: 1) Pilot on top 20 products using Next.js, 2) Measure: indexing speed, SEO rankings, page load (Core Web Vitals), 3) If successful: migrate remaining public pages, 4) Keep CSR for authenticated pages (cart, dashboard). Cost: 4-6 weeks dev time (~¬£25k) + hosting increase (¬£200-400/mo). ROI: If 10,000 products √ó 10 searches/product/month √ó 5% CTR √ó 2% conversion √ó ¬£50 AOV = significant revenue gain if not currently indexed." }
    },
    // DAYS 16-21 - Content to be added based on the detailed structure already outlined
    // These days will cover: Authentication, Payments, Webhooks, Queues, Search, Integration Patterns
    // Each following the same comprehensive 1500+ word format with 5 questions and essay

    { day: 16, week: 2, title: "Authentication & Authorization", desc: "Sessions, JWT, OAuth explained", duration: "55 min", coldOpen: "Security audit found users can access other users' orders by changing URL. Your dev says 'we have login'. What's the difference between authentication and authorization?", coldRevisit: "Authentication = proving who you are (login). Authorization = what you're allowed to do (permissions). You need both. Broken authorization is a top security issue.", content: "<h2>Why This Matters to You</h2><p>Authentication and authorization are different but both critical. Authentication proves identity ('you are user@email.com'). Authorization controls access ('you can only see your own orders'). Mixing them up leads to security breaches‚Äîusers accessing others' data, unauthorized admin access.</p><h2>1. Authentication vs Authorization</h2><table><tr><th>Authentication</th><th>Authorization</th></tr><tr><td>Who are you?</td><td>What can you do?</td></tr><tr><td>Login with email/password</td><td>Check if user can access resource</td></tr><tr><td>Verify identity</td><td>Enforce permissions</td></tr><tr><td>Happens once (login)</td><td>Happens on every request</td></tr><tr><td>Example: Entering username/password</td><td>Example: Checking if order belongs to user</td></tr></table><h2>2. Session-Based Authentication</h2><pre>// Traditional session approach\n// 1. User logs in\nPOST /login\n{ email: 'user@example.com', password: 'secret123' }\n\n// 2. Server validates, creates session\nconst session = {\n  userId: 123,\n  email: 'user@example.com',\n  createdAt: Date.now()\n};\nsessionStore.set(sessionId, session);\n\n// 3. Server sends session cookie\nSet-Cookie: sessionId=abc123; HttpOnly; Secure\n\n// 4. Browser sends cookie on every request\nGET /api/orders\nCookie: sessionId=abc123\n\n// 5. Server validates session\nconst session = sessionStore.get(request.cookies.sessionId);\nif (!session) return 401; // Unauthorized</pre><h3>Session Pros/Cons</h3><ul><li><strong>Pros:</strong> Simple, can revoke immediately (delete from store), server controls everything</li><li><strong>Cons:</strong> Requires session storage (Redis/database), harder to scale across servers</li></ul><h2>3. Token-Based Authentication (JWT)</h2><pre>// JWT (JSON Web Token) approach\n// 1. User logs in\nPOST /login\n{ email: 'user@example.com', password: 'secret123' }\n\n// 2. Server creates signed token\nconst token = jwt.sign(\n  { userId: 123, email: 'user@example.com' },\n  SECRET_KEY,\n  { expiresIn: '7d' }\n);\n// Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n\n// 3. Client stores token (localStorage or cookie)\nlocalStorage.setItem('token', token);\n\n// 4. Client sends token on every request\nGET /api/orders\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n\n// 5. Server verifies token signature\nconst decoded = jwt.verify(token, SECRET_KEY);\nif (!decoded) return 401;\n// Token is valid, decoded.userId = 123</pre><h3>JWT Pros/Cons</h3><ul><li><strong>Pros:</strong> Stateless (no server storage), scales easily, works across domains</li><li><strong>Cons:</strong> Can't revoke (until expiry), larger payload, secret key must be secure</li></ul><h2>4. Authorization: Checking Permissions</h2><pre>// Bad: No authorization check\napp.get('/api/orders/:orderId', (req, res) => {\n  const order = await getOrder(req.params.orderId);\n  return res.json(order);  // Anyone can see any order!\n});\n\n// Good: Verify order belongs to user\napp.get('/api/orders/:orderId', requireAuth, async (req, res) => {\n  const order = await getOrder(req.params.orderId);\n  \n  // Authorization check\n  if (order.userId !== req.user.id) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  return res.json(order);\n});</pre><h2>5. OAuth: Third-Party Login</h2><p>OAuth lets users log in with Google, Facebook, etc.:</p><pre>// OAuth flow (simplified)\n1. User clicks 'Login with Google'\n2. Redirect to Google with your app credentials\n3. User approves access\n4. Google redirects back with authorization code\n5. Exchange code for access token\n6. Use token to get user info from Google\n7. Create session/JWT in your system</pre><h3>When to Use OAuth</h3><ul><li><strong>Use:</strong> Reduce friction (users don't need another password), trust established providers</li><li><strong>Don't use:</strong> If you need fine-grained control, complex permission requirements</li></ul><h2>6. Password Security</h2><pre>// WRONG: Never store passwords in plain text!\nusers.insert({\n  email: 'user@example.com',\n  password: 'secret123'  // Database breach = all passwords leaked!\n});\n\n// CORRECT: Hash with bcrypt (slow by design)\nconst bcrypt = require('bcrypt');\nconst hashedPassword = await bcrypt.hash(password, 10);\nusers.insert({\n  email: 'user@example.com',\n  password: hashedPassword  // Leak shows hash, not original password\n});\n\n// Verify login\nconst isValid = await bcrypt.compare(inputPassword, user.password);</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è Critical Security Rules</div><ul><li>Never store passwords in plain text</li><li>Always hash with bcrypt (not MD5 or SHA1)</li><li>Use HTTPS for all authentication endpoints</li><li>HttpOnly cookies prevent XSS theft</li><li>Implement rate limiting on login attempts</li></ul></div><h2>7. Common Vulnerabilities</h2><table><tr><th>Vulnerability</th><th>Attack</th><th>Prevention</th></tr><tr><td><strong>Broken Authorization</strong></td><td>Access other users' data by changing URL/ID</td><td>Always verify resource belongs to user</td></tr><tr><td><strong>Session Fixation</strong></td><td>Attacker sets victim's session ID</td><td>Regenerate session ID after login</td></tr><tr><td><strong>XSS Token Theft</strong></td><td>JavaScript steals token from localStorage</td><td>Use HttpOnly cookies instead</td></tr><tr><td><strong>CSRF</strong></td><td>Malicious site makes request as logged-in user</td><td>CSRF tokens, SameSite cookies</td></tr></table>", questions: [{ q: "Security audit shows users can view others' orders by changing the order ID in the URL. What's the issue?", opts: ["Need better authentication", "Broken authorization: system authenticates (knows who you are) but doesn't authorize (check if you own that order). Must verify resource ownership on every request.", "Need HTTPS", "Password security issue"], correct: 1, explain: "This is authorization failure, not authentication. User is logged in (authenticated) but system doesn't check if they own the requested resource. Always verify: does this resource belong to this user?" }, { q: "What's the key difference between sessions and JWTs?", opts: ["Sessions are more secure", "Sessions store state on server (can revoke anytime, requires storage). JWTs are stateless (self-contained, can't revoke until expiry, no server storage needed).", "JWTs are newer", "No real difference"], correct: 1, explain: "Sessions: server stores session data, can revoke immediately. JWTs: stateless tokens, can't revoke (until expiry), no server storage. Trade-off: control vs scalability." }, { q: "Developer stored passwords using MD5 hash. Is this secure?", opts: ["Yes‚Äîpasswords are hashed", "No‚ÄîMD5 is fast and crackable. Must use bcrypt, which is intentionally slow to resist brute-force attacks. MD5 hashes can be cracked in minutes.", "Yes if passwords are strong", "Only a problem if database is leaked"], correct: 1, explain: "MD5 is too fast‚Äîattackers can try billions of passwords per second. Bcrypt is intentionally slow (tunable), making brute-force attacks impractical. Always use bcrypt for passwords." }, { q: "Your app stores JWT tokens in localStorage. Security consultant says this is vulnerable. Why?", opts: ["localStorage is outdated", "XSS attacks can steal tokens from localStorage via JavaScript. HttpOnly cookies can't be accessed by JavaScript, preventing XSS theft. Use HttpOnly cookies for sensitive tokens.", "localStorage is slow", "Tokens should be in sessionStorage"], correct: 1, explain: "XSS vulnerability: malicious JavaScript can read localStorage and steal tokens. HttpOnly cookies are inaccessible to JavaScript, protecting against XSS. For sensitive auth, use HttpOnly + Secure cookies." }, { q: "What does HttpOnly flag on cookies prevent?", opts: ["HTTP connections", "JavaScript access to cookie, preventing XSS attacks from stealing authentication tokens. Cookie is only sent in HTTP requests, not readable via document.cookie.", "HTTPS requirement", "Cookie expiration"], correct: 1, explain: "HttpOnly prevents JavaScript from reading cookies. Without it, XSS attacks can steal auth tokens via document.cookie. With HttpOnly, cookies are HTTP-only‚Äîsent in requests but not accessible to scripts." }], essay: { q: "Your security audit found: 1) Users can access others' orders by changing URLs, 2) Passwords stored with MD5, 3) No rate limiting on login. How do you prioritize fixes? What's the business risk of each?", guide: "Prioritize: 1) Authorization (CRITICAL): Users can access others' data‚Äîprivacy breach, legal liability (GDPR), immediate exploitation risk. Fix: Add ownership checks to all API endpoints. 2) Password hashing (HIGH): Database breach exposes passwords. MD5 cracks in minutes. Users reuse passwords across sites. Fix: Migrate to bcrypt. 3) Rate limiting (MEDIUM): Enables brute-force attacks. Fix: Limit login attempts. Timeline: Authorization fixes can be deployed in days (add checks per endpoint). Password migration requires user communication (force password reset). Rate limiting is quick (middleware). Business risk: Authorization breach could be PR disaster + legal liability + customer trust loss. Estimate cost of breach vs fix cost." } },
    { day: 17, week: 2, title: "Payment Integration", desc: "Stripe, PCI compliance, security", duration: "55 min", coldOpen: "CFO asks: 'Are we PCI compliant?' You're not sure. Your dev says 'We use Stripe'. Does that mean you're compliant? What are the implications if you're not?", coldRevisit: "Using Stripe correctly = PCI compliant (Stripe handles card data, you never see it). If you store card numbers or CVVs = you must be PCI certified (expensive audit). Non-compliance = fines + banned from processing cards.", content: "<h2>Why This Matters to You</h2><p>Payment processing is heavily regulated. PCI DSS (Payment Card Industry Data Security Standard) has strict requirements. Violating them can result in fines up to $100k/month and loss of ability to process cards. Understanding how Stripe and PCI work helps you avoid expensive mistakes.</p><h2>1. PCI Compliance Levels</h2><table><tr><th>Level</th><th>Transaction Volume (yearly)</th><th>Requirements</th></tr><tr><td>Level 1</td><td>&gt; 6 million</td><td>Annual on-site audit by QSA, quarterly scans</td></tr><tr><td>Level 2</td><td>1-6 million</td><td>Annual self-assessment, quarterly scans</td></tr><tr><td>Level 3</td><td>20k - 1 million</td><td>Annual self-assessment, quarterly scans</td></tr><tr><td>Level 4</td><td>&lt; 20k</td><td>Annual self-assessment (may vary by processor)</td></tr></table><p><strong>Cost of compliance:</strong> Level 1 audit costs $50k-300k. Level 4 self-assessment costs $2k-5k.</p><h2>2. The Right Way: Stripe Checkout/Elements</h2><pre>// CORRECT: Card data never touches your server\n&lt;form id=\"payment-form\"&gt;\n  &lt;!-- Stripe Elements: iframe hosted by Stripe --&gt;\n  &lt;div id=\"card-element\"&gt;&lt;/div&gt;\n  &lt;button&gt;Pay&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;script&gt;\n  const stripe = Stripe('pk_test_...');\n  const elements = stripe.elements();\n  const cardElement = elements.create('card');\n  cardElement.mount('#card-element');\n  \n  form.addEventListener('submit', async (e) => {\n    e.preventDefault();\n    \n    // Stripe converts card to token (card data never hits your server)\n    const {token, error} = await stripe.createToken(cardElement);\n    \n    if (error) {\n      // Handle error\n    } else {\n      // Send token to your server (not card number!)\n      const response = await fetch('/charge', {\n        method: 'POST',\n        body: JSON.stringify({ token: token.id, amount: 5000 })\n      });\n    }\n  });\n&lt;/script&gt;\n\n// Your server: charge the token\nconst charge = await stripe.charges.create({\n  amount: 5000,  // $50.00\n  currency: 'usd',\n  source: req.body.token,  // Token from frontend\n  description: 'Order #123'\n});</pre><div class=\"info-box\"><div class=\"info-title\">üí° Why This Works</div><p>Card data goes directly from customer ‚Üí Stripe (via iframe). Your server only sees tokens. You never store, process, or transmit card data. Result: Easiest PCI compliance (SAQ A: 22 questions).</p></div><h2>3. The Wrong Way: Storing Card Data</h2><pre>// WRONG: Card data touches your server\n&lt;form action=\"/charge\" method=\"POST\"&gt;\n  &lt;input name=\"cardNumber\" /&gt;      &lt;!-- PCI violation! --&gt;\n  &lt;input name=\"cardCVV\" /&gt;        &lt;!-- PCI violation! --&gt;\n  &lt;input name=\"cardExpiry\" /&gt;     &lt;!-- PCI violation! --&gt;\n  &lt;button&gt;Pay&lt;/button&gt;\n&lt;/form&gt;\n\n// Server receives card data directly\napp.post('/charge', (req, res) => {\n  const cardNumber = req.body.cardNumber;  // Now you're responsible for PCI!\n  // Even if you don't store it, you processed it = PCI applies\n});</pre><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è PCI Violation Consequences</div><ul><li>Fines: $5k-100k per month</li><li>Banned from processing cards</li><li>Liable for breaches (millions in damages)</li><li>Audit costs: $50k-300k annually</li></ul></div><h2>4. Stripe Integration: Step by Step</h2><pre>// 1. Backend: Create Payment Intent\napp.post('/create-payment-intent', async (req, res) => {\n  const paymentIntent = await stripe.paymentIntents.create({\n    amount: 5000,\n    currency: 'usd',\n    metadata: { orderId: '123' }\n  });\n  \n  res.json({ clientSecret: paymentIntent.client_secret });\n});\n\n// 2. Frontend: Collect card details\nconst {clientSecret} = await fetch('/create-payment-intent').then(r => r.json());\n\nconst {error} = await stripe.confirmCardPayment(clientSecret, {\n  payment_method: {\n    card: cardElement,\n    billing_details: { name: 'Customer Name' }\n  }\n});\n\nif (error) {\n  // Payment failed\n} else {\n  // Payment succeeded!\n}</pre><h2>5. Webhooks: Handling Async Events</h2><pre>// Stripe sends webhooks for payment events\napp.post('/webhook', express.raw({type: 'application/json'}), (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  let event;\n  \n  try {\n    // Verify webhook signature (critical security)\n    event = stripe.webhooks.constructEvent(req.body, sig, WEBHOOK_SECRET);\n  } catch (err) {\n    return res.status(400).send(`Webhook Error: ${err.message}`);\n  }\n  \n  // Handle event\n  switch (event.type) {\n    case 'payment_intent.succeeded':\n      // Payment succeeded - fulfill order\n      fulfillOrder(event.data.object.metadata.orderId);\n      break;\n    case 'payment_intent.payment_failed':\n      // Payment failed - notify customer\n      notifyCustomer(event.data.object.metadata.orderId);\n      break;\n  }\n  \n  res.json({received: true});\n});</pre><h2>6. Common Payment Mistakes</h2><table><tr><th>Mistake</th><th>Impact</th><th>Fix</th></tr><tr><td>Storing card numbers</td><td>PCI violation, fines, audit costs</td><td>Use Stripe tokens/Payment Intents</td></tr><tr><td>Not verifying webhook signatures</td><td>Attackers can fake payment confirmations</td><td>Always verify stripe-signature header</td></tr><tr><td>Fulfilling orders before payment confirms</td><td>Orders fulfilled, payment fails</td><td>Use webhooks, check payment status</td></tr><tr><td>No idempotency keys</td><td>Duplicate charges if user refreshes</td><td>Use idempotency keys in API calls</td></tr></table>", questions: [{ q: "Your CFO asks if you're PCI compliant. You use Stripe Checkout. What do you answer?", opts: ["Need to get audited first", "Yes‚Äîusing Stripe Checkout/Elements properly means card data never touches our servers. We're SAQ A compliant (simplest level, 22 questions).", "Stripe handles it", "Not sure"], correct: 1, explain: "Using Stripe Checkout/Elements correctly = SAQ A (simplest PCI level). Card data goes directly to Stripe. You never see, store, or process card numbers. Result: easiest compliance." }, { q: "Developer says we should store card numbers 'encrypted' in our database for faster future purchases. Your response?", opts: ["Good idea if encrypted well", "No‚Äîstoring card data requires expensive PCI certification, audits, and increased breach liability. Use Stripe's saved payment methods instead.", "Yes but use strong encryption", "Check with legal first"], correct: 1, explain: "Storing card data (even encrypted) = full PCI audit ($50k+), ongoing compliance costs, massive liability if breached. Stripe offers saved payment methods‚Äîyou store token, Stripe stores card." }, { q: "What's the security risk if you don't verify webhook signatures?", opts: ["Webhooks will fail", "Attackers can send fake payment success webhooks to your endpoint, causing you to fulfill orders without actual payment.", "Slower processing", "No major risk"], correct: 1, explain: "Without signature verification, anyone can POST to your webhook endpoint claiming 'payment succeeded'. Verify stripe-signature header to ensure webhook came from Stripe." }, { q: "Customer reports being charged twice. What likely happened?", opts: ["Stripe bug", "No idempotency key used. User clicked Pay twice (or refreshed), creating two charges. Stripe's idempotency keys prevent duplicate charges for same request.", "Database issue", "Race condition"], correct: 1, explain: "Without idempotency keys, rapid duplicate requests create duplicate charges. Stripe's idempotency keys (unique per request) ensure same request never charges twice, even if submitted multiple times." }, { q: "When should you fulfill an order after Stripe payment?", opts: ["Immediately when form submits", "Only after payment_intent.succeeded webhook confirms payment. Don't trust client-side confirmation alone‚Äîcan be spoofed.", "After user confirms", "When payment status is 'processing'"], correct: 1, explain: "Wait for payment_intent.succeeded webhook. Client-side confirmations can be faked. Webhooks are server-to-server and signature-verified. Only fulfill orders after webhook confirms payment succeeded." }], essay: { q: "Your dev proposes storing encrypted card numbers for 'faster checkout'. What are the PCI implications? What's the cost/benefit analysis? What's the Stripe alternative?", guide: "PCI implications: Storing card data (even encrypted) requires: 1) Annual PCI audit ($50k-300k for Level 1), 2) Quarterly vulnerability scans, 3) Extensive security controls (firewalls, encryption, access logs), 4) Massive liability if breached (legal + fines + customer notification). Cost: $100k+ annually in compliance + dev time. Benefit: Slightly faster checkout. Analysis: Not worth it. Stripe alternative: Payment Methods API. Store Stripe payment method ID (pm_xxx), Stripe stores actual card. Customer's saved cards work in one click, zero PCI burden for you. Recommendation: Use Stripe's saved payment methods. Same UX, 99% less cost and risk." } },
    { day: 18, week: 2, title: "Webhooks & Event Architecture", desc: "Asynchronous integrations", duration: "50 min", coldOpen: "Your shipping partner wants a webhook endpoint. Your dev asks 'where should I create this?' and 'what security do we need?' What are webhooks and why do they matter?", coldRevisit: "Webhooks = reverse APIs. Instead of you calling them (polling), they POST to your endpoint when events happen. Must verify signatures (prevent fake requests) and handle idempotency (same event sent twice).", content: "<h2>Why This Matters</h2><p>Webhooks enable real-time integrations without polling. When an order ships, Shippo POSTs to your webhook immediately‚Äîno need to check every 5 minutes. But webhooks introduce security and reliability challenges you must understand to approve implementations.</p><h2>1. Webhooks vs Polling</h2><table><tr><th>Polling (Old Way)</th><th>Webhooks (Modern Way)</th></tr><tr><td>You repeatedly ask: 'Any updates?'</td><td>They tell you immediately when something happens</td></tr><tr><td>Wastes API calls (mostly 'no updates')</td><td>Efficient‚Äîonly called when needed</td></tr><tr><td>Delayed (check every 5-60 minutes)</td><td>Real-time (instant notification)</td></tr><tr><td>You control timing</td><td>They control timing</td></tr></table><h2>2. How Webhooks Work</h2><pre>// Sequence:\n1. You give Shippo your webhook URL: https://yoursite.com/webhooks/shippo\n2. Event happens (package ships)\n3. Shippo POSTs to your URL:\n   POST https://yoursite.com/webhooks/shippo\n   {\n     event: 'shipment.delivered',\n     trackingNumber: '1Z999AA10123456784',\n     orderId: 'ORDER-123'\n   }\n4. Your endpoint receives, processes event\n5. You respond with 200 OK (they retry if not 200)</pre><h2>3. Security: Verifying Signatures</h2><pre>// BAD: No verification (attacker can fake events)\napp.post('/webhooks/shippo', (req, res) => {\n  const event = req.body;\n  markOrderAsShipped(event.orderId);  // Trusts any POST!\n  res.sendStatus(200);\n});\n\n// GOOD: Verify signature\napp.post('/webhooks/shippo', (req, res) => {\n  const signature = req.headers['x-shippo-signature'];\n  const payload = JSON.stringify(req.body);\n  \n  // Verify HMAC signature\n  const expectedSig = crypto\n    .createHmac('sha256', WEBHOOK_SECRET)\n    .update(payload)\n    .digest('hex');\n  \n  if (signature !== expectedSig) {\n    return res.status(401).json({ error: 'Invalid signature' });\n  }\n  \n  // Signature valid - process event\n  markOrderAsShipped(req.body.orderId);\n  res.sendStatus(200);\n});</pre><h2>4. Idempotency: Handling Duplicates</h2><pre>// Webhooks may be sent multiple times (network issues, retries)\n// Must handle idempotently (same event twice = same result)\n\napp.post('/webhooks/payment', async (req, res) => {\n  const eventId = req.body.id;\n  \n  // Check if already processed\n  const processed = await webhookLog.findOne({ eventId });\n  if (processed) {\n    return res.sendStatus(200);  // Already handled, return success\n  }\n  \n  // Process event\n  await fulfillOrder(req.body.orderId);\n  \n  // Log as processed\n  await webhookLog.create({ eventId, processedAt: new Date() });\n  \n  res.sendStatus(200);\n});</pre><h2>5. Error Handling & Retries</h2><pre>// Providers retry if you don't respond 200\n// Retry schedule typically: immediate, 1 min, 5 min, 30 min, 1 hour...\n\napp.post('/webhooks/stripe', async (req, res) => {\n  try {\n    const event = verifyStripeWebhook(req);\n    \n    await processEvent(event);\n    \n    // Must respond 200 quickly (within 5-10 seconds)\n    res.sendStatus(200);\n    \n  } catch (error) {\n    // Log error for debugging\n    console.error('Webhook error:', error);\n    \n    // Return 500 so provider retries\n    res.sendStatus(500);\n  }\n});</pre>", questions: [{ q: "What's the main security risk of webhooks if not properly verified?", opts: ["Slow performance", "Anyone can POST fake events to your endpoint, triggering actions (marking orders shipped, crediting accounts) without actual events occurring.", "CORS issues", "Memory leaks"], correct: 1, explain: "Without signature verification, attackers can fake webhooks (POST to your endpoint with fake data). Always verify signatures using HMAC with shared secret." }, { q: "Why must webhook handlers be idempotent?", opts: ["For speed", "Providers retry webhooks if they don't get 200 response. Same event may be delivered multiple times. Idempotent handling ensures same event processed twice has same result (no duplicate actions).", "To reduce database load", "For security"], correct: 1, explain: "Webhooks are retried on failure, network issues, or timeouts. You might receive same event 2-3 times. Idempotent handling (check if already processed, store event ID) prevents duplicate actions." }, { q: "Shippo webhook endpoint takes 15 seconds to process. What's the problem?", opts: ["15 seconds is fine", "Webhook providers expect quick response (5-10 sec max). Slow response = timeout = retry. Solution: Respond 200 immediately, process event in background queue.", "Need faster server", "Database is slow"], correct: 1, explain: "Webhooks timeout if you take too long. Pattern: 1) Verify signature, 2) Queue event for processing, 3) Respond 200 immediately, 4) Process async in background. Don't do heavy work in webhook handler." }, { q: "What's the benefit of webhooks vs polling every 5 minutes?", opts: ["Webhooks are newer", "Real-time updates (instant vs 5-min delay), efficient (only called when needed vs constant polling), reduced API usage (no wasted 'no update' calls).", "Webhooks are easier to implement", "Better security"], correct: 1, explain: "Webhooks are event-driven (push) vs polling (pull). Webhooks: instant, efficient. Polling: delayed (5-min average), wasteful (99% of polls return 'no change'). For real-time needs, webhooks are superior." }, { q: "How do you handle a webhook event that depends on data not yet in your database (race condition)?", opts: ["Ignore the webhook", "Implement retry logic: if dependency missing, queue event for retry in 30 seconds. After 3-5 retries, log failure for manual investigation.", "Request webhooks slower", "Disable webhooks"], correct: 1, explain: "Race conditions happen (webhook arrives before API sync completes). Solution: Check dependencies, queue for retry if missing. After retries exhausted, alert for manual check. Don't assume order of operations." }], essay: { q: "Partner wants webhook endpoint for order updates. Your dev asks about security and implementation. What guidance do you provide?", guide: "Security requirements: 1) Verify signature (HMAC with shared secret), 2) Use HTTPS only, 3) Log all webhook attempts, 4) Rate limiting (prevent DOS). Implementation guidance: 1) Respond 200 quickly (<5 sec), 2) Queue actual processing for background, 3) Handle idempotency (store event IDs to prevent duplicate processing), 4) Implement retry logic for dependencies. Architecture: POST /webhooks/partner -> verify signature -> queue event -> respond 200 -> background worker processes. Monitoring: Track success rate, failure reasons, processing time. Testing: Partner should provide test events/signature. Document: What events do we handle? What triggers what actions?" } },
    { day: 19, week: 2, title: "Message Queues & Background Jobs", desc: "Async processing for reliability", duration: "50 min", coldOpen: "Checkout takes 12 seconds. Dev says it's because we 'send confirmation email, update inventory, create Shippo label, notify Slack, update analytics' during checkout. Can this be faster?", coldRevisit: "Yes‚Äîonly critical work happens synchronously (charge card, create order). Everything else queues for background processing. Checkout should be 2-3 seconds, background jobs handle rest.", content: "<h2>Why This Matters</h2><p>Slow checkout = abandoned carts. If your checkout takes 10+ seconds, you're doing too much work synchronously. Message queues let you defer non-critical work to background, responding to users in 2-3 seconds while completing work asynchronously.</p><h2>1. Synchronous vs Asynchronous Work</h2><table><tr><th>Must Be Synchronous</th><th>Can Be Async (Queued)</th></tr><tr><td>Charge payment card</td><td>Send confirmation email</td></tr><tr><td>Create order record</td><td>Generate shipping label</td></tr><tr><td>Check inventory</td><td>Update analytics</td></tr><tr><td>Generate order ID</td><td>Notify Slack/internal systems</td></tr><tr><td></td><td>Process recommendations</td></tr><tr><td></td><td>Generate PDF receipt</td></tr></table><h2>2. Without Queue (Slow Checkout)</h2><pre>app.post('/checkout', async (req, res) => {\n  const start = Date.now();\n  \n  // 1. Charge card (500ms)\n  const charge = await stripe.charges.create({...});\n  \n  // 2. Create order (100ms)\n  const order = await db.orders.create({...});\n  \n  // 3. Send email (2000ms) - SLOW!\n  await sendgrid.send({ to: user.email, ... });\n  \n  // 4. Create shipping label (1500ms) - SLOW!\n  await shippo.createLabel({...});\n  \n  // 5. Update inventory (300ms)\n  await updateInventory(order.items);\n  \n  // 6. Notify Slack (800ms) - SLOW!\n  await slack.post({ text: `New order ${order.id}` });\n  \n  // 7. Update analytics (500ms)\n  await analytics.track('purchase', {...});\n  \n  const elapsed = Date.now() - start;\n  // Total: ~5700ms (5.7 seconds)\n  // User waited entire time!\n  \n  res.json({ orderId: order.id });\n});</pre><h2>3. With Queue (Fast Checkout)</h2><pre>app.post('/checkout', async (req, res) => {\n  // 1. Charge card (500ms)\n  const charge = await stripe.charges.create({...});\n  \n  // 2. Create order (100ms)\n  const order = await db.orders.create({...});\n  \n  // 3. Queue all non-critical work\n  await queue.add('send-confirmation-email', { orderId: order.id });\n  await queue.add('create-shipping-label', { orderId: order.id });\n  await queue.add('update-inventory', { orderId: order.id });\n  await queue.add('notify-slack', { orderId: order.id });\n  await queue.add('track-analytics', { orderId: order.id });\n  \n  // Total: ~600ms\n  // User gets response immediately!\n  \n  res.json({ orderId: order.id });\n});\n\n// Background workers process queue\nqueue.process('send-confirmation-email', async (job) => {\n  await sendgrid.send({ to: job.data.email, ... });\n});\n\nqueue.process('create-shipping-label', async (job) => {\n  await shippo.createLabel({...});\n});</pre><h2>4. Message Queue Architecture</h2><pre>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  API    ‚îÇ ---enqueue---&gt;  ‚îÇ   Queue   ‚îÇ  ---dequeue---&gt; ‚îÇ   Worker   ‚îÇ\n‚îÇ Server  ‚îÇ                  ‚îÇ  (Redis)  ‚îÇ                  ‚îÇ  Process   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n   Quick                       Persistent                     Async\n   Response                    Storage                        Processing</pre><h2>5. Popular Queue Libraries</h2><table><tr><th>Library</th><th>Backend</th><th>Features</th><th>Best For</th></tr><tr><td><strong>BullMQ</strong></td><td>Redis</td><td>Retries, delays, priorities, rate limiting</td><td>Most use cases</td></tr><tr><td><strong>Sidekiq</strong></td><td>Redis</td><td>Ruby ecosystem, mature</td><td>Rails apps</td></tr><tr><td><strong>Celery</strong></td><td>Redis/RabbitMQ</td><td>Python ecosystem, distributed tasks</td><td>Python apps</td></tr><tr><td><strong>AWS SQS</strong></td><td>AWS</td><td>Managed service, scales automatically</td><td>AWS infrastructure</td></tr></table><h2>6. Job Retries & Error Handling</h2><pre>// Configure retries and backoff\nqueue.add('send-email', \n  { to: 'user@example.com', orderId: 123 },\n  {\n    attempts: 5,\n    backoff: {\n      type: 'exponential',\n      delay: 1000  // 1s, 2s, 4s, 8s, 16s\n    }\n  }\n);\n\n// Handle failures\nqueue.on('failed', (job, error) => {\n  console.error(`Job ${job.id} failed after ${job.attemptsMade} attempts:`, error);\n  \n  // After all retries exhausted\n  if (job.attemptsMade >= job.opts.attempts) {\n    // Alert team, store in dead letter queue\n    alertOps(`Job ${job.id} permanently failed`);\n  }\n});</pre>", questions: [{ q: "Checkout endpoint takes 8 seconds. What work should you move to a background queue?", opts: ["Charging the payment card", "Everything except: charging card, creating order record, checking inventory. Queue: emails, shipping labels, analytics, notifications.", "Create order record", "All of it"], correct: 1, explain: "Only critical work must be synchronous: charge card, create order, check inventory. Everything else (emails, labels, analytics, notifications) can queue for background processing. Reduces checkout to 1-3 seconds." }, { q: "What happens if a background job fails (email service down)?", opts: ["Job is lost", "Queue automatically retries with exponential backoff (1s, 2s, 4s...). After configured attempts (usually 5-10), job moves to dead letter queue for manual review.", "Must restart server", "Immediate alert"], correct: 1, explain: "Queues provide automatic retries with backoff. Temporary failures (network glitch) succeed on retry. Permanent failures (bad email) exhaust retries and go to dead letter queue for investigation." }, { q: "Why use Redis for a message queue instead of a database?", opts: ["Redis is newer", "Redis is in-memory (fast), optimized for queue operations (push/pop), supports atomic operations, and has built-in pub/sub. Databases are slower and not designed for high-frequency queue operations.", "Databases don't support queues", "Redis is free"], correct: 1, explain: "Redis excels at queue operations: in-memory (microsecond latency), atomic operations, pub/sub support. Databases work but are slower (disk I/O) and not optimized for constant push/pop operations at scale." }, { q: "How do you handle jobs that depend on previous jobs (generate PDF after shipping label created)?", opts: ["Run them synchronously", "Chain jobs: first job (create label) completes successfully ‚Üí enqueue second job (generate PDF). Or use job dependencies feature in BullMQ.", "Poll database", "Manual coordination"], correct: 1, explain: "Job chaining: When job 1 completes, it enqueues job 2. Or use queue library's dependency feature (BullMQ supports parent-child jobs). Never do this synchronously in checkout flow‚Äîdefeats queue purpose." }, { q: "Your checkout is fast but confirmation emails arrive 30 minutes later. What's the problem?", opts: ["Email provider is slow", "Workers are overwhelmed (too many jobs, not enough workers) or worker crash/not running. Check: worker process status, queue depth, processing rate. May need more workers.", "Queue is broken", "Database is slow"], correct: 1, explain: "Long delays indicate worker capacity issue: 1) Workers crashed (not processing), 2) Too few workers for job volume, 3) Jobs backed up in queue. Solution: Monitor queue depth, scale workers, check worker process health." }], essay: { q: "Your checkout takes 10 seconds because it sends email, creates shipping label, updates 3 systems, and logs to analytics. How do you redesign this? What stays synchronous? What goes to queue? What's the user experience?", guide: "Current flow analysis: Payment charge (required): 500ms, Create order (required): 200ms, Email (can queue): 2s, Shipping label (can queue): 1.5s, Update systems (can queue): 800ms, Analytics (can queue): 300ms. Total: 10.3s. Redesign: Synchronous: 1) Charge card, 2) Create order, 3) Check inventory, 4) Respond to user. Queue: 5) Email, 6) Shipping label, 7) System updates, 8) Analytics. New total: 700ms response. UX: Checkout completes in <1 second, show 'Order confirmed! Confirmation email coming shortly.' Background workers process queue (30-60 seconds total). Monitoring: Track queue depth, job failures, processing time. Alert if queue depth > 1000 or jobs failing. Implementation: Use BullMQ with Redis, 3-5 worker processes, exponential retry, dead letter queue for failures." } },
    { day: 20, week: 2, title: "Search Implementation", desc: "Full-text search, facets, relevance", duration: "55 min", coldOpen: "Customer searches 'blue headphones' and gets zero results. You have 50 blue headphones in stock. Search is working 'as designed'. What's wrong and how much does this cost you?", coldRevisit: "Text normalization issue: 'Blue' vs 'blue', 'headphone' vs 'headphones'. Without proper tokenization, stemming, and fuzzy matching, search misses obvious matches. Every zero-result search is a lost sale. Fix: Use proper search engine (Elasticsearch, Algolia) with NLP.", content: "<h2>Why This Matters</h2><p>Search directly impacts revenue. 30% of ecommerce visitors use search, and searchers convert 2-3x higher than non-searchers. Poor search (zero results, irrelevant results) = lost sales. Understanding search technology helps you evaluate when basic database queries aren't enough.</p><h2>1. Database Query vs Search Engine</h2><pre>// Database query (simple but limited)\nSELECT * FROM products \nWHERE name LIKE '%headphones%'\nORDER BY created_at DESC;\n\nProblems:\n- Case sensitive ('Headphones' !== 'headphones')\n- Exact match only (no typos: 'hedphones' = 0 results)\n- No relevance ranking (oldest first, not best match)\n- No word variations ('headphone' !== 'headphones')\n- Slow on large datasets (full table scan)\n\n// Search engine (sophisticated)\n// Handles: stemming, typos, synonyms, relevance\n// Returns blue headphones for: \n// 'blue headphones', 'Blue Headphone', 'blu hedphones', 'azure earphones'</pre><h2>2. Search Features Matrix</h2><table><tr><th>Feature</th><th>Database LIKE</th><th>Full-Text Search</th><th>Search Engine</th></tr><tr><td>Case insensitive</td><td>Manual (LOWER())</td><td>‚úì</td><td>‚úì</td></tr><tr><td>Partial matches</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr><tr><td>Typo tolerance</td><td>‚úó</td><td>‚úó</td><td>‚úì</td></tr><tr><td>Stemming (run/running)</td><td>‚úó</td><td>‚úì</td><td>‚úì</td></tr><tr><td>Synonyms (big/large)</td><td>‚úó</td><td>‚úó</td><td>‚úì</td></tr><tr><td>Relevance ranking</td><td>‚úó</td><td>Basic</td><td>Advanced</td></tr><tr><td>Faceted search</td><td>Complex SQL</td><td>‚úó</td><td>‚úì</td></tr><tr><td>Speed at scale</td><td>Slow</td><td>Medium</td><td>Fast</td></tr></table><h2>3. Search Engine Options</h2><table><tr><th>Solution</th><th>Hosting</th><th>Cost</th><th>Best For</th></tr><tr><td><strong>Algolia</strong></td><td>Hosted</td><td>$1/1k searches</td><td>Fast implementation, excellent UX</td></tr><tr><td><strong>Elasticsearch</strong></td><td>Self-hosted/Cloud</td><td>$50-500/mo</td><td>Flexibility, large catalogs</td></tr><tr><td><strong>Typesense</strong></td><td>Self-hosted/Cloud</td><td>$30-200/mo</td><td>Elasticsearch alternative, simpler</td></tr><tr><td><strong>Meilisearch</strong></td><td>Self-hosted</td><td>Free/paid hosting</td><td>Open source, lightweight</td></tr><tr><td><strong>Database full-text</strong></td><td>Existing DB</td><td>Free</td><td>Small catalogs, basic needs</td></tr></table><h2>4. Implementing Algolia (Fast Setup)</h2><pre>// 1. Index your products\nconst algoliasearch = require('algoliasearch');\nconst client = algoliasearch('APP_ID', 'API_KEY');\nconst index = client.initIndex('products');\n\nconst products = await db.products.findAll();\nawait index.saveObjects(products.map(p => ({\n  objectID: p.id,\n  name: p.name,\n  description: p.description,\n  price: p.price,\n  category: p.category,\n  inStock: p.inventory > 0\n})));\n\n// 2. Frontend search (instant results)\nconst results = await index.search('blue headphones', {\n  filters: 'inStock:true',\n  facets: ['category', 'price_range'],\n  hitsPerPage: 20\n});\n\n// Results include:\n// - Matched products (with typo tolerance)\n// - Facets (categories: Electronics(45), Audio(23)...)\n// - Highlighting (shows matched terms)\n// - Response time: ~20ms</pre><h2>5. Search UX Best Practices</h2><pre>// Autocomplete (as-you-type suggestions)\nconst suggestions = await index.search(query, {\n  hitsPerPage: 5,\n  attributesToRetrieve: ['name', 'image', 'price'],\n  attributesToHighlight: ['name']\n});\n\n// Faceted search (filters)\n&lt;div&gt;\n  &lt;h3&gt;Category&lt;/h3&gt;\n  {facets.category.map(facet =&gt; (\n    &lt;label&gt;\n      &lt;input type=\"checkbox\" value={facet.value} /&gt;\n      {facet.value} ({facet.count})\n    &lt;/label&gt;\n  ))}\n&lt;/div&gt;\n\n// Zero-results handling\nif (results.hits.length === 0) {\n  // Don't show empty page\n  // Options:\n  // 1. Suggest alternative spelling\n  // 2. Show popular products\n  // 3. Show products from related categories\n  // 4. Log query for analysis (what are users searching for?)\n}</pre><h2>6. Relevance Tuning</h2><pre>// Configure searchable attributes with ranking\nindex.setSettings({\n  searchableAttributes: [\n    'name',           // Highest priority\n    'brand',\n    'category',\n    'description'     // Lowest priority\n  ],\n  customRanking: [\n    'desc(popularity)',  // Popular products rank higher\n    'asc(price)'        // Cheaper products rank higher\n  ],\n  attributesForFaceting: [\n    'category',\n    'brand',\n    'price_range',\n    'color'\n  ]\n});</pre><h2>7. Measuring Search Performance</h2><pre>// Key metrics to track\nSearch Metrics:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Metric                     ‚îÇ Target   ‚îÇ Action  ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Zero-result searches       ‚îÇ < 10%    ‚îÇ Analyze ‚îÇ\n‚îÇ Search-to-purchase rate    ‚îÇ 15-30%   ‚îÇ Improve ‚îÇ\n‚îÇ Average results per search ‚îÇ 10-100   ‚îÇ Refine  ‚îÇ\n‚îÇ Search latency             ‚îÇ < 100ms  ‚îÇ Optimize‚îÇ\n‚îÇ Top searches (no results)  ‚îÇ Weekly   ‚îÇ Review  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n// Log zero-result searches\nif (results.nbHits === 0) {\n  await analytics.track('search-zero-results', {\n    query: query,\n    userId: user.id,\n    timestamp: Date.now()\n  });\n}</pre>", questions: [{ q: "Customer searches 'blu hedphones' (typos). Database LIKE query returns zero results. What's missing?", opts: ["Database is broken", "Typo tolerance (fuzzy matching). Search engines use Levenshtein distance to match similar terms. 'blu hedphones' matches 'blue headphones' with 2-edit distance.", "Need better database", "Customer error"], correct: 1, explain: "Databases do exact matching. Search engines use fuzzy matching‚Äîtolerates 1-2 character differences. 'blu' matches 'blue', 'hedphones' matches 'headphones'. Critical for good search UX." }, { q: "20% of searches return zero results. How do you diagnose what's wrong?", opts: ["Search is working correctly", "Log all zero-result queries, analyze patterns: Are they typos? Missing products? Wrong synonyms? Out-of-stock items? Fix: Add typo tolerance, configure synonyms, stock missing products.", "Users search wrong", "Disable search"], correct: 1, explain: "Zero-result rate should be <10%. Log queries to identify patterns: typos (need fuzzy search), missing products (stock them), synonyms (configure: 'laptop' = 'notebook'), discontinued items (suggest alternatives)." }, { q: "Your product catalog has 50,000 items. Database LIKE queries are slow. What's the problem?", opts: ["Need more RAM", "LIKE queries scan entire table (no index). At 50k+ products, this is slow. Solution: Use full-text index (database) or search engine (Elasticsearch/Algolia) for fast lookups.", "Database is too small", "Need SSD storage"], correct: 1, explain: "LIKE '%term%' can't use indexes‚Äîfull table scan. Slow at scale. Full-text indexes or dedicated search engines are optimized for text search: tokenization, inverted indexes, fast lookups." }, { q: "When does database full-text search suffice vs needing a dedicated search engine?", opts: ["Always use search engine", "Database full-text OK for: <10k products, simple search (no typos/synonyms), low traffic. Need search engine for: large catalogs, typo tolerance, relevance tuning, high traffic, faceted search.", "Never use database search", "Doesn't matter"], correct: 1, explain: "Trade-off: Database full-text is free, simple. Search engines add cost/complexity but provide typo tolerance, synonyms, relevance ranking, speed at scale. Evaluate based on catalog size and search sophistication needed." }, { q: "What's the business impact of search that returns zero results 30% of the time?", opts: ["Users try again", "30% of searches = lost sales. Searchers are high-intent (2-3x conversion). Zero results = frustration + bounce. If 1000 searches/day, 300 zero results, 10% would buy at ¬£50 AOV = ¬£1,500/day lost = ¬£45k/month.", "Search isn't important", "Users will browse instead"], correct: 1, explain: "Searchers are high-intent buyers. Zero results = immediate bounce. Calculate: searches √ó zero-result rate √ó estimated conversion √ó AOV. Even conservative estimates show significant revenue loss from poor search." }], essay: { q: "Your site has 10,000 products. Currently using database LIKE queries. 25% of searches return zero results, customers complain. Evaluate search engine options (Algolia, Elasticsearch, database full-text). What's the cost/benefit?", guide: "Current problems: LIKE query limitations (no typo tolerance, no stemming, slow, no relevance ranking). 25% zero results = lost sales. Options: 1) Database full-text (PostgreSQL/MySQL): Free, better than LIKE, but limited typo tolerance. Good for: basic improvement, testing. 2) Elasticsearch: $50-200/mo hosting, full features, requires management. Good for: large catalogs, full control. 3) Algolia: ~$100-500/mo, instant setup, excellent UX, no management. Good for: fast implementation, focus on business. Recommendation: For 10k products + 25% zero results, Algolia worth investment. Calculate: If 1000 searches/day, 250 zero results, fixing reduces to 10% zero = 150 more successful searches. At 20% conversion √ó ¬£50 AOV = ¬£1,500/day additional revenue = ¬£45k/month. $500/mo Algolia cost pays for itself 90x over. Pilot: Try Algolia 14-day trial, measure zero-result rate improvement and conversion impact." } },
    { day: 21, week: 2, title: "Week 2 Review & Integration Patterns", desc: "Connecting systems effectively", duration: "45 min", coldOpen: "Systems are 'tightly coupled'‚Äîchanging checkout requires updates to 5 other systems. Every deploy risks breaking something. How do you fix this architecture?", coldRevisit: "Loose coupling via events: Checkout publishes 'order.created' event. Other systems subscribe independently. Change checkout = no ripple effects. Event-driven architecture enables independent scaling and deployment.", content: "<h2>Week 2 Review: Backend & Integrations</h2><p>This week covered backend systems: SSR/SSG, authentication, payments, webhooks, queues, and search. The common theme: integration patterns‚Äîhow systems connect without becoming tangled.</p><h2>1. Coupling: The Core Problem</h2><pre>// Tight coupling (bad)\nfunction checkout(order) {\n  // Checkout directly calls 5 systems\n  paymentService.charge(order);         // If this changes, checkout breaks\n  inventoryService.reduce(order);       // If this changes, checkout breaks\n  shippingService.createLabel(order);   // If this changes, checkout breaks\n  emailService.send(order);             // If this changes, checkout breaks\n  analyticsService.track(order);        // If this changes, checkout breaks\n  \n  // Must deploy all 6 systems together\n  // One failure breaks entire checkout\n}\n\n// Loose coupling (good)\nfunction checkout(order) {\n  // Checkout publishes event\n  eventBus.publish('order.created', order);\n  \n  // Other systems subscribe independently\n  // payment-service subscribes to order.created\n  // inventory-service subscribes to order.created\n  // shipping-service subscribes to order.created\n  // email-service subscribes to order.created\n  // analytics-service subscribes to order.created\n  \n  // Each system deploys independently\n  // One failure doesn't break checkout\n}</pre><h2>2. Integration Patterns Summary</h2><table><tr><th>Pattern</th><th>When to Use</th><th>Example</th></tr><tr><td><strong>REST API</strong></td><td>Request-response, real-time</td><td>Get product details</td></tr><tr><td><strong>Webhooks</strong></td><td>Event notification, push</td><td>Payment succeeded</td></tr><tr><td><strong>Message Queue</strong></td><td>Async work, retries</td><td>Send confirmation email</td></tr><tr><td><strong>Event Bus</strong></td><td>Loose coupling, many subscribers</td><td>Order created ‚Üí 5 services</td></tr><tr><td><strong>Polling</strong></td><td>Third-party no webhooks</td><td>Check shipping status</td></tr></table><h2>3. Event-Driven Architecture</h2><pre>// Central event bus\nconst eventBus = new EventEmitter();\n\n// Publisher (checkout service)\napp.post('/checkout', async (req, res) => {\n  const order = await createOrder(req.body);\n  \n  // Publish event\n  eventBus.emit('order.created', {\n    orderId: order.id,\n    userId: order.userId,\n    total: order.total,\n    items: order.items\n  });\n  \n  res.json({ orderId: order.id });\n});\n\n// Subscribers (independent services)\neventBus.on('order.created', async (order) => {\n  await emailService.sendConfirmation(order);  // Email service\n});\n\neventBus.on('order.created', async (order) => {\n  await inventoryService.reduce(order.items);  // Inventory service\n});\n\neventBus.on('order.created', async (order) => {\n  await shippingService.createLabel(order);    // Shipping service\n});\n\n// Add new subscriber without changing checkout\neventBus.on('order.created', async (order) => {\n  await fraudService.check(order);             // New: Fraud detection\n});</pre><h2>4. Week 2 Key Takeaways</h2><ul><li><strong>SSR vs CSR:</strong> Public pages need SEO = SSR/SSG. Authenticated pages = CSR OK.</li><li><strong>Authentication:</strong> Login proves identity. Authorization checks permissions. Need both.</li><li><strong>Payments:</strong> Use Stripe properly = easy PCI compliance. Store cards = expensive audits.</li><li><strong>Webhooks:</strong> Verify signatures, handle idempotency, respond quickly.</li><li><strong>Queues:</strong> Defer non-critical work. Checkout should be <3 seconds.</li><li><strong>Search:</strong> Database LIKE = limited. Search engines = typos + relevance + speed.</li><li><strong>Integration:</strong> Loose coupling via events = independent deployment + scalability.</li></ul>", questions: [{ q: "What's the main benefit of event-driven architecture over direct service calls?", opts: ["Faster performance", "Loose coupling: services don't know about each other, only events. Can add/remove/modify services without changing others. Failure in one service doesn't break others.", "Easier to code", "Better security"], correct: 1, explain: "Event-driven decouples services. Checkout publishes 'order.created'. Services subscribe independently. Add fraud check? Subscribe to event. Email fails? Doesn't break checkout. Direct calls = tightly coupled." }, { q: "Your checkout calls 8 services directly. One service is slow (3 seconds). What happens?", opts: ["Checkout is slow (3+ seconds), user waits", "Checkout is slow (3+ seconds), user waits. All services are synchronous. Solution: Use events or queues‚Äîcheckout publishes event, services process async.", "Only that service is affected", "Need faster servers"], correct: 0, explain: "Synchronous calls = sequential wait time. If one service takes 3s, checkout takes 3s minimum. Solution: Async via events or queues. Checkout completes in <1s, services process in background." }, { q: "How do you prevent cascading failures in service architecture?", opts: ["Use faster servers", "Loose coupling (events not direct calls), circuit breakers (stop calling failing service), retries with backoff, fallbacks (degrade gracefully), monitoring (detect issues fast).", "Restart services often", "Increase timeouts"], correct: 1, explain: "Cascading failure prevention: 1) Loose coupling (failure doesn't propagate), 2) Circuit breakers (stop calling broken service), 3) Graceful degradation (continue without failed service), 4) Retries with backoff, 5) Monitoring + alerts." }, { q: "Week 2 covered many integration patterns. What's the decision framework?", opts: ["Always use newest technology", "Real-time sync data? REST API. Event notification? Webhook. Async work? Queue. Multiple subscribers? Event bus. Third-party no webhooks? Polling. Choose based on requirements, not hype.", "Use what competitors use", "Flip a coin"], correct: 1, explain: "Pattern selection based on use case: REST (request-response), Webhooks (push notifications), Queues (async work with retries), Event bus (many subscribers), Polling (no other option). Match pattern to problem." }, { q: "Your architecture has checkout ‚Üí email service ‚Üí analytics service (chain). Email fails = analytics doesn't run. How to fix?", opts: ["Make email service more reliable", "Don't chain services. Checkout should publish event, both email and analytics subscribe independently. Email failure doesn't affect analytics. Each service is autonomous.", "Add retries", "Duplicate analytics call"], correct: 1, explain: "Chaining creates dependencies‚Äîeach failure blocks downstream. Event-driven: checkout publishes event ‚Üí email subscribes ‚Üí analytics subscribes. Both are independent. Email fails? Analytics still runs." }], essay: { q: "Your checkout service directly calls 10 other services (payment, email, inventory, shipping, etc.). This is slow, fragile, and hard to change. Design a better architecture. What patterns do you use? How does this improve reliability and speed?", guide: "Current problems: Tight coupling (checkout knows about all 10 services), synchronous (slow‚Äîsum of all service times), fragile (one failure breaks checkout), hard to change (adding service requires checkout changes). Better architecture: Event-driven. Checkout: 1) Charge payment (must be sync), 2) Create order, 3) Publish 'order.created' event, 4) Respond to user (<1s). Other services: Subscribe to 'order.created' event, process independently. Benefits: Speed (checkout: <1s vs 5-10s), Reliability (email fails? checkout succeeds), Scalability (add fraud check? just subscribe to event), Maintainability (change inventory? doesn't affect checkout). Implementation: Use message queue (Redis + BullMQ) or event bus (EventEmitter, or AWS EventBridge). Each service is autonomous microservice or background worker. Monitoring: Track event publishing, processing times, failure rates. Result: Fast checkout, resilient architecture, easy to extend." } },
    // DAY 22 - PLATFORM ARCHITECTURE
    {
        day: 22,
        week: 3,
        title: "Platform Architecture",
        desc: "Monolith vs microservices",
        duration: "55 min",
        coldOpen: "Your CTO proposes migrating to microservices: 8-month project, 4 engineers full-time. Your monolith works but is 'becoming hard to maintain'. How do you evaluate if this ¬£256k investment is justified?",
        coldRevisit: "Microservices solve specific problems: independent scaling, team autonomy, technology diversity. But add massive complexity: distributed debugging, network failures, deployment coordination. Only justified when monolith problems are severe and team is large (15+ engineers). Most companies should start with a modular monolith.",
        content: "<h2>Why This Matters to You</h2><p>Microservices are heavily hyped but expensive and complex. A migration can cost ¬£200k-500k and take 6-12 months. Many migrations fail or deliver limited value. Understanding when microservices actually make sense helps you avoid expensive mistakes and ask the right questions when your CTO proposes a migration.</p><h2>1. Monolith vs Microservices</h2><table><tr><th>Aspect</th><th>Monolith</th><th>Microservices</th></tr><tr><td><strong>Definition</strong></td><td>One application, one codebase, deploys together</td><td>Many small services, separate codebases, deploy independently</td></tr><tr><td><strong>Communication</strong></td><td>Function calls (in-process)</td><td>Network calls (HTTP/RPC)</td></tr><tr><td><strong>Database</strong></td><td>Usually one shared database</td><td>Each service has own database</td></tr><tr><td><strong>Deployment</strong></td><td>Deploy entire app at once</td><td>Deploy services independently</td></tr><tr><td><strong>Scaling</strong></td><td>Scale entire app together</td><td>Scale services independently</td></tr><tr><td><strong>Complexity</strong></td><td>Low (one app to understand)</td><td>High (many services, networking, orchestration)</td></tr></table><h2>2. Monolith Architecture</h2><pre>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ         Monolith Application        ‚îÇ\n‚îÇ                                     ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ\n‚îÇ  ‚îÇ   API    ‚îÇ  ‚îÇ  Frontend   ‚îÇ    ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ\n‚îÇ  ‚îÇ Business ‚îÇ  ‚îÇ   Data      ‚îÇ    ‚îÇ\n‚îÇ  ‚îÇ  Logic   ‚îÇ  ‚îÇ   Access    ‚îÇ    ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ\n‚îÇ                                     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n           ‚Üì\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ   Database   ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n// All code in one repository\n// All features deploy together\n// Fast function calls (no network)\n// Transactions work easily (ACID)</pre><h2>3. Microservices Architecture</h2><pre>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Product   ‚îÇ     ‚îÇ   Order     ‚îÇ     ‚îÇ  Payment    ‚îÇ\n‚îÇ   Service   ‚îÇ‚Üê‚îÄ‚îÄ‚îÄ‚Üí‚îÇ   Service   ‚îÇ‚Üê‚îÄ‚îÄ‚îÄ‚Üí‚îÇ  Service    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n      ‚Üì                   ‚Üì                   ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Product DB ‚îÇ     ‚îÇ  Order DB   ‚îÇ     ‚îÇ Payment DB  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n// Separate repositories\n// Independent deployment\n// Network calls (slower, can fail)\n// Distributed transactions (complex)</pre><h2>4. When Microservices Make Sense</h2><table><tr><th>Problem</th><th>How Microservices Help</th><th>Minimum Team Size</th></tr><tr><td><strong>Independent scaling</strong></td><td>Scale only the services that need it (e.g., product search gets 10x traffic)</td><td>10+ engineers</td></tr><tr><td><strong>Team autonomy</strong></td><td>Teams own services end-to-end, deploy independently without coordination</td><td>15+ engineers (2-3 teams)</td></tr><tr><td><strong>Technology diversity</strong></td><td>Use different languages/frameworks per service (search in Go, checkout in Node)</td><td>10+ engineers</td></tr><tr><td><strong>Clear domain boundaries</strong></td><td>Services map to business domains (product catalog, order management, payments)</td><td>Any size (but complexity not worth it for small teams)</td></tr></table><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The Team Size Rule</div><p>Microservices add ~30% development overhead (networking, deployment, debugging). Small teams (< 10 engineers) should almost never use microservices‚Äîthe overhead outweighs benefits. You need 2-3 full teams (15+ engineers) to justify the complexity.</p></div><h2>5. The Hidden Costs of Microservices</h2><pre>Monolith costs:\n- Development: Straightforward\n- Testing: One app to test\n- Deployment: One deploy\n- Monitoring: One app to monitor\n- Debugging: Stack traces work\n- Total overhead: ~10%\n\nMicroservices costs:\n- Development: API contracts, versioning\n- Testing: Integration tests across services\n- Deployment: Coordinate multiple services\n- Monitoring: Distributed tracing needed\n- Debugging: Trace across 5-10 services\n- Networking: Calls fail, retries, timeouts\n- Data consistency: Distributed transactions\n- Total overhead: ~30-40%</pre><h2>6. The Middle Ground: Modular Monolith</h2><p>Best of both worlds‚Äîmonolith with clear internal boundaries:</p><pre>// Modular monolith structure\nsrc/\n  modules/\n    products/\n      api/\n      services/\n      models/\n    orders/\n      api/\n      services/\n      models/\n    payments/\n      api/\n      services/\n      models/\n\n// Rules:\n// 1. Modules can't directly access other modules' internals\n// 2. Communication via well-defined APIs\n// 3. Each module could become a service later\n\n// Example: Orders can't directly query products database\n// BAD: \nconst product = await db.products.findById(123);  // Direct access\n\n// GOOD:\nconst product = await ProductsAPI.getProduct(123);  // Through API\n\n// Benefits:\n// - Still one deployment (simple)\n// - Clear boundaries (can extract services later if needed)\n// - Fast function calls (no network overhead)\n// - Easy transactions (single database)</pre><h2>7. Migration Path: Monolith ‚Üí Microservices</h2><pre>Phase 1: Modular Monolith (3 months)\n- Refactor into clear modules\n- Define internal APIs\n- No external changes\n- Cost: ¬£72k (3 months √ó 3 devs √ó ¬£8k)\n\nPhase 2: Extract One Service (3 months)\n- Extract highest-value service (e.g., search)\n- Learn microservices challenges\n- Measure: deployment speed, scaling benefits\n- Cost: ¬£72k\n\nPhase 3: Evaluate\n- Did Phase 2 solve real problems?\n- Was complexity worth it?\n- Continue or stop?\n\nPhase 4: Extract More Services (6-12 months)\n- Only if Phase 3 shows clear value\n- Extract 2-3 more services\n- Cost: ¬£144k-288k\n\nTotal: ¬£288k-432k over 12-18 months</pre><h2>8. Microservices Decision Matrix</h2><table><tr><th>Your Situation</th><th>Recommendation</th><th>Why</th></tr><tr><td>< 10 engineers</td><td>Monolith (modular if growing)</td><td>Overhead not justified</td></tr><tr><td>10-15 engineers</td><td>Modular monolith</td><td>Prepare for future, but stay simple</td></tr><tr><td>15-30 engineers</td><td>Consider microservices</td><td>Team autonomy benefits emerge</td></tr><tr><td>30+ engineers</td><td>Microservices likely make sense</td><td>Multiple teams, independent deployment critical</td></tr><tr><td>Startup, pre-product-market fit</td><td>Monolith</td><td>Speed of iteration > architecture</td></tr><tr><td>Established, complex domain</td><td>Modular monolith or microservices</td><td>Depends on team size</td></tr></table><h2>9. Common Microservices Mistakes</h2><table><tr><th>Mistake</th><th>Impact</th><th>Prevention</th></tr><tr><td><strong>Too many services</strong></td><td>30 services for 8 engineers = constant coordination</td><td>Start with 3-5 services max</td></tr><tr><td><strong>Wrong boundaries</strong></td><td>Services that constantly call each other (chatty)</td><td>Follow domain boundaries, not technical layers</td></tr><tr><td><strong>Shared database</strong></td><td>Services aren't truly independent</td><td>Each service owns its data</td></tr><tr><td><strong>Distributed monolith</strong></td><td>Microservices complexity + monolith coupling = worst of both</td><td>Ensure services can deploy independently</td></tr></table><div class=\"info-box\"><div class=\"info-title\">üí° The Amazon/Netflix Argument</div><p>\"Amazon and Netflix use microservices!\" Yes, with:<br>‚Ä¢ Amazon: 1.6 million employees<br>‚Ä¢ Netflix: 11,000 engineers<br><br>Your 8-person team isn't Amazon. Different scale = different solutions. Don't cargo-cult big tech architecture.</p></div><h2>10. Questions to Ask Your CTO</h2><pre>When CTO proposes microservices:\n\n1. What specific problems are we solving?\n   - Be specific (not 'scalability'‚Äîwhat can't scale?)\n   - Quantify (deployment takes X hours, want Y minutes)\n\n2. Have we tried alternatives?\n   - Modular monolith?\n   - Better caching/databases?\n   - Horizontal scaling of monolith?\n\n3. What's the cost?\n   - Dev time: X months √ó Y engineers\n   - New infrastructure (service mesh, monitoring)\n   - Ongoing overhead (30-40% slower feature development)\n\n4. What's the migration path?\n   - Big bang (risky) or incremental (safer)?\n   - Can we extract one service as pilot?\n\n5. Do we have the expertise?\n   - Distributed systems are hard\n   - Do we understand: eventual consistency, circuit breakers, distributed tracing?\n\n6. How do we measure success?\n   - Deployment frequency increase?\n   - Scaling cost decrease?\n   - Team velocity improve?\n   - Define metrics before starting</pre>",
        questions: [
            { q: "Your CTO proposes microservices. Your team has 8 engineers. Your response?", opts: ["Approve‚Äîmicroservices are modern best practice", "Ask: What problems are we solving? With 8 engineers, microservices overhead (30-40%) outweighs benefits. Consider modular monolith instead‚Äîclear boundaries, simpler deployment.", "Reject immediately‚Äînever use microservices", "Hire 10 more engineers first"], correct: 1, explain: "Small teams (< 10 engineers) rarely benefit from microservices. The overhead (distributed debugging, deployment coordination, networking) slows development. Modular monolith provides clear boundaries without the complexity." },
            { q: "What's a 'modular monolith' and when does it make sense?", opts: ["An outdated pattern", "Monolith with clear internal module boundaries. Modules communicate via defined APIs. Benefits: monolith simplicity + clear boundaries. Can extract modules to services later if needed. Best for most teams.", "A compromise that satisfies no one", "Only for legacy systems"], correct: 1, explain: "Modular monolith = best of both worlds. Clear module boundaries (like microservices) but single deployment (like monolith). Most teams should start here‚Äîget boundaries right, extract services only if problems emerge." },
            { q: "What's the main hidden cost of microservices?", opts: ["Higher cloud bills", "30-40% development overhead: distributed debugging (trace across services), deployment coordination, network failures/retries, eventual consistency, API versioning, distributed tracing/monitoring. Slows feature development significantly.", "Hiring specialized engineers", "Licensing costs"], correct: 1, explain: "Microservices add 30-40% overhead. Simple features now require coordinating changes across services, handling network failures, and distributed debugging. Only justified when benefits (independent scaling/deployment) outweigh this cost." },
            { q: "Your CTO says 'Amazon uses microservices, we should too.' Your response?", opts: ["Agree‚Äîcopy successful companies", "Amazon has 1.6M employees and different problems at extreme scale. Your 12-person team isn't Amazon. Architecture should match your team size and problems, not imitate big tech.", "Microservices don't work at scale", "Hire more engineers to match Amazon"], correct: 1, explain: "Cargo-culting big tech is dangerous. Amazon's architecture solves Amazon-scale problems with Amazon-sized teams. Your 10-person team has different constraints. Match architecture to your team and scale, not someone else's." },
            { q: "If you do migrate to microservices, what's the safest approach?", opts: ["Rewrite everything in 6 months (big bang)", "Incremental: 1) Create modular monolith, 2) Extract one high-value service as pilot, 3) Measure benefits vs costs, 4) Continue only if clear value. Never big-bang rewrite.", "Hire consultants to do it", "Start with 20 microservices"], correct: 1, explain: "Incremental migration is safer: modular monolith first, extract one service, learn from experience, measure actual benefits. Big-bang rewrites typically fail‚Äîtimelines slip 2-3x, new bugs, business impact." }
        ],
        essay: { q: "Your CTO proposes an 8-month microservices migration for your 12-person engineering team. Current monolith 'works but is hard to maintain'. How do you evaluate this proposal? What questions do you ask? What's the cost/benefit analysis?", guide: "Cost analysis: 8 months √ó 3 engineers full-time √ó ¬£8k/mo = ¬£192k direct cost. Indirect cost: 3 engineers not building features = ¬£192k opportunity cost. Total: ¬£384k. Questions: 1) What specific problems? ('Hard to maintain' is vague‚Äîis it deployment speed? scaling? team conflicts?). 2) Tried alternatives? (Modular monolith refactor = 2-3 months, ¬£72k, 80% of benefits). 3) Team expertise? (Distributed systems are hard‚Äîdo we have experience?). 4) What if monolith but with better structure? (Extract modules, improve test coverage, add monitoring). Recommendation: Almost never approve 8-month big-bang migration. Instead: Phase 1 (3 months, ¬£72k): Refactor to modular monolith. Measure: is 'hard to maintain' solved? If yes, stop here. If no: Phase 2 (3 months, ¬£72k): Extract one service as pilot. Measure: deployment speed, scaling, development velocity. If clear benefit: continue. If marginal: stop. Total pilot cost: ¬£144k vs ¬£384k, less risk, faster value. Most companies should stop at modular monolith." }
    },
    // DAY 23 - PERFORMANCE MONITORING
    {
        day: 23,
        week: 3,
        title: "Performance Monitoring & Observability",
        desc: "Proactive monitoring, metrics, and alerting",
        duration: "55 min",
        coldOpen: "Your site was down for 45 minutes before you knew‚Äîcustomers reported it. Your team says 'we have Google Analytics'. Is that enough? What monitoring do you actually need?",
        coldRevisit: "Google Analytics shows user behavior but misses technical failures. Need: 1) Uptime monitoring (is site up?), 2) Error tracking (what's breaking?), 3) Performance monitoring (is it slow?), 4) Business metrics (revenue impact). Alert BEFORE customers notice.",
        content: "<h2>Why This Matters to You</h2><p>Finding out about outages from customers is embarrassing and costly. 45 minutes of downtime for an ecommerce site doing ¬£1M/month = ¬£30k lost revenue. Proactive monitoring catches issues before customers notice, provides data for root cause analysis, and helps you evaluate if technical problems are affecting revenue.</p><h2>1. The Four Pillars of Monitoring</h2><table><tr><th>Pillar</th><th>What It Monitors</th><th>Questions Answered</th><th>Tools</th></tr><tr><td><strong>Uptime</strong></td><td>Is site accessible?</td><td>Can customers reach us?</td><td>Pingdom, UptimeRobot</td></tr><tr><td><strong>Errors</strong></td><td>Application exceptions</td><td>What's breaking? Where?</td><td>Sentry, Rollbar</td></tr><tr><td><strong>Performance</strong></td><td>Speed, resource usage</td><td>Is site slow? Why?</td><td>New Relic, Datadog</td></tr><tr><td><strong>Business</strong></td><td>Conversions, revenue</td><td>Technical issues affecting sales?</td><td>Google Analytics, Mixpanel</td></tr></table><h2>2. Uptime Monitoring</h2><pre>// External monitoring (checks from outside)\nPingdom checks every 60 seconds:\n‚îú‚îÄ https://yoursite.com ‚Üí 200 OK ‚úì\n‚îú‚îÄ https://yoursite.com/api/health ‚Üí 200 OK ‚úì\n‚îú‚îÄ https://yoursite.com/checkout ‚Üí 200 OK ‚úì\n\nIf ANY check fails:\n1. Retry 3 times (avoid false positives)\n2. Alert via: SMS, email, Slack, PagerDuty\n3. Start incident timer\n\nCost: $10-50/month\nValue: Know instantly when site is down</pre><h3>Uptime SLAs</h3><table><tr><th>SLA</th><th>Downtime/Year</th><th>Downtime/Month</th><th>Realistic?</th></tr><tr><td>99%</td><td>3.65 days</td><td>7.2 hours</td><td>Too low</td></tr><tr><td>99.9% (three nines)</td><td>8.76 hours</td><td>43.2 minutes</td><td>Good target</td></tr><tr><td>99.99% (four nines)</td><td>52.6 minutes</td><td>4.3 minutes</td><td>Expensive to achieve</td></tr><tr><td>99.999% (five nines)</td><td>5.26 minutes</td><td>26 seconds</td><td>Reserved for critical systems</td></tr></table><div class=\"info-box\"><div class=\"info-title\">üí° The 99.9% Target</div><p>Most ecommerce sites should target 99.9% uptime (43 minutes downtime/month). Going from 99.9% to 99.99% typically doubles infrastructure costs. Only pursue higher SLAs if downtime cost justifies investment.</p></div><h2>3. Error Monitoring</h2><pre>// Sentry integration (catches JavaScript/backend errors)\n// Automatically captures:\n\n// Frontend errors\ntry {\n  JSON.parse(invalidJSON);\n} catch (error) {\n  // Sentry captures: error message, stack trace, user context, breadcrumbs\n}\n\n// Backend errors\napp.post('/checkout', async (req, res) => {\n  try {\n    await processCheckout(req.body);\n  } catch (error) {\n    // Sentry captures: error, request data, user ID, environment\n    Sentry.captureException(error);\n    res.status(500).json({ error: 'Checkout failed' });\n  }\n});\n\n// Sentry dashboard shows:\n// - Error frequency (100 errors/hour ‚Üí spike detected)\n// - Affected users (500 users affected)\n// - Stack traces (exact line where error occurred)\n// - Release tracking (error started in v2.3.1)\n// - Breadcrumbs (what user did before error)</pre><h2>4. Performance Monitoring (APM)</h2><pre>// Application Performance Monitoring tracks:\n\n// Response times (percentiles)\np50: 200ms   // 50% of requests faster than this (median)\np90: 450ms   // 90% faster\np95: 800ms   // 95% faster (important: catches slow outliers)\np99: 2000ms  // 99% faster (very slow edge cases)\n\nWhy percentiles > average?\nAverage: 300ms (looks fine)\np95: 5000ms (5% of users wait 5 seconds!)\n\nPercentiles reveal problems average hides.</pre><h2>5. Key Metrics to Track</h2><table><tr><th>Metric</th><th>What It Measures</th><th>Target</th><th>Alert If</th></tr><tr><td><strong>Uptime %</strong></td><td>Site availability</td><td>99.9%</td><td>Site down > 1 min</td></tr><tr><td><strong>Error rate</strong></td><td>% of requests failing</td><td>< 0.1%</td><td>> 1% or 10x baseline</td></tr><tr><td><strong>p95 response time</strong></td><td>95th percentile speed</td><td>< 500ms</td><td>> 1000ms</td></tr><tr><td><strong>Apdex score</strong></td><td>User satisfaction (0-1)</td><td>> 0.9</td><td>< 0.8</td></tr><tr><td><strong>Checkout completion</strong></td><td>% who complete checkout</td><td>75-80%</td><td>< 70% or 20% drop</td></tr><tr><td><strong>Revenue/hour</strong></td><td>Business health</td><td>Baseline √ó 0.8</td><td>30%+ drop</td></tr></table><h2>6. Alerting Strategy</h2><pre>// Alert levels (prioritize correctly)\n\nüö® CRITICAL (wake up team)\n- Site completely down\n- Payment processing failing\n- Error rate > 5%\n- Revenue dropped 50%\nAction: Immediate response required\n\n‚ö†Ô∏è WARNING (investigate during work hours)\n- p95 response time > 1000ms\n- Error rate > 0.5%\n- Checkout completion < 70%\nAction: Investigate root cause, plan fix\n\nüìä INFO (track trends)\n- Traffic spike (not necessarily bad)\n- Slow gradual degradation\n- Resource usage increasing\nAction: Monitor, plan capacity\n\n// Alert fatigue prevention:\n// 1. Use thresholds (not every error)\n// 2. Group related alerts\n// 3. Suppress during known maintenance\n// 4. Escalate only critical alerts to SMS</pre><h2>7. Monitoring Stack (Typical Setup)</h2><table><tr><th>Tool</th><th>Purpose</th><th>Cost</th><th>Setup Time</th></tr><tr><td><strong>Pingdom</strong></td><td>Uptime monitoring</td><td>$10-50/mo</td><td>30 minutes</td></tr><tr><td><strong>Sentry</strong></td><td>Error tracking</td><td>$26-80/mo</td><td>1 hour</td></tr><tr><td><strong>New Relic/Datadog</strong></td><td>APM (performance)</td><td>$100-500/mo</td><td>2-4 hours</td></tr><tr><td><strong>LogRocket/FullStory</strong></td><td>Session replay</td><td>$100-300/mo</td><td>2 hours</td></tr><tr><td><strong>Google Analytics</strong></td><td>Business metrics</td><td>Free-$150k/yr</td><td>1 hour</td></tr></table><div class=\"warning-box\"><div class=\"warning-title\">‚ö†Ô∏è The Minimum Setup</div><p>At minimum, you MUST have:<br>1. Uptime monitoring (Pingdom, $10/mo)<br>2. Error tracking (Sentry, $26/mo)<br>3. Business metrics (Google Analytics, free)<br><br>Without these, you're flying blind. Total cost: $36/month = 2% of one developer's salary.</p></div><h2>8. Dashboards That Matter</h2><pre>// Executive dashboard (daily review)\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Yesterday's Health                ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ  Uptime:           99.95% ‚úì         ‚îÇ\n‚îÇ  Error rate:       0.03% ‚úì          ‚îÇ\n‚îÇ  p95 latency:      420ms ‚úì          ‚îÇ\n‚îÇ  Checkout rate:    77% ‚úì            ‚îÇ\n‚îÇ  Revenue:          ¬£34,567 (+3%)    ‚îÇ\n‚îÇ  Incidents:        0 ‚úì              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n// Engineering dashboard (real-time)\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Right Now                         ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ  Requests/sec:     245              ‚îÇ\n‚îÇ  Error rate:       0.01%            ‚îÇ\n‚îÇ  Active users:     1,234            ‚îÇ\n‚îÇ  Response times:   p50: 180ms       ‚îÇ\n‚îÇ                    p95: 450ms       ‚îÇ\n‚îÇ  Database:         420 queries/sec  ‚îÇ\n‚îÇ  Queue depth:      15 jobs          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</pre><h2>9. Correlation: Technical + Business Metrics</h2><pre>// Example: Slow checkout affecting revenue\n\nTimeline:\n10:00 AM - p95 checkout time: 400ms (normal)\n10:15 AM - p95 checkout time: 2000ms (5x slower)\n10:15 AM - Checkout completion: 78% ‚Üí 65% (drops 13%)\n10:15 AM - Revenue/hour: ¬£3k ‚Üí ¬£2.6k (down 15%)\n\nCorrelation found!\nSlow performance ‚Üí abandoned checkouts ‚Üí lost revenue\n\nRoot cause investigation:\n- Check: Recent deploys? (Yes, v2.4.0 at 10:10 AM)\n- Check: Database slow queries? (Yes, missing index)\n- Check: Third-party API? (Stripe API responding slowly)\n\nFix deployed 10:45 AM:\n- Rollback to v2.3.9\n- Checkout time returns to 400ms\n- Completion rate returns to 78%\n\nRevenue impact:\n30 minutes slow checkout √ó ¬£400/hr lost = ¬£200\nQuick detection + fix prevented ¬£2k+ additional loss.</pre><h2>10. Incident Response Workflow</h2><pre>1. ALERT FIRES\n   ‚îî‚îÄ> Slack: \"üö® Site down (3 checks failed)\"\n   ‚îî‚îÄ> SMS to on-call engineer\n\n2. ACKNOWLEDGE (< 5 minutes)\n   ‚îî‚îÄ> Engineer: \"I'm investigating\"\n   ‚îî‚îÄ> Status page: \"Investigating connectivity issues\"\n\n3. DIAGNOSE (< 15 minutes)\n   ‚îî‚îÄ> Check: Uptime monitor, error logs, recent deploys\n   ‚îî‚îÄ> Root cause: Database out of connections\n\n4. MITIGATE (< 30 minutes)\n   ‚îî‚îÄ> Quick fix: Restart database, increase connection pool\n   ‚îî‚îÄ> Status: \"Issue identified, implementing fix\"\n\n5. RESOLVE\n   ‚îî‚îÄ> Confirm: Site responding, errors cleared\n   ‚îî‚îÄ> Status: \"Resolved. Monitoring closely.\"\n\n6. POSTMORTEM (within 48 hours)\n   ‚îî‚îÄ> What happened? Why? Timeline?\n   ‚îî‚îÄ> Action items: Prevent recurrence\n   ‚îî‚îÄ> Share learnings with team</pre>",
        questions: [
            { q: "What's the difference between average response time and p95 response time, and why does p95 matter more?", opts: ["No real difference", "Average hides outliers. If 95% of requests are 200ms but 5% are 10 seconds, average might be 500ms (looks fine) but p95 is 10s (bad UX for 5% of users). p95 reveals slow experiences average masks.", "p95 is just a fancy metric", "Average is more accurate"], correct: 1, explain: "Average response time is misleading‚Äîslow outliers are averaged away. p95 shows: 95% of requests are faster than this. If p95 is 5 seconds, 5% of your users wait 5+ seconds (terrible experience). Always monitor percentiles, not averages." },
            { q: "Your site was down for 30 minutes before you knew. Customers reported it. What monitoring is missing?", opts: ["Better customer service", "Uptime monitoring (Pingdom, etc). External checks every 60 seconds from multiple locations. Alerts via SMS/Slack when site unreachable. Cost: $10-20/month. Without it, you only know from customer complaints.", "More servers", "Google Analytics"], correct: 1, explain: "External uptime monitoring ($10-20/mo) checks your site every minute from outside your infrastructure. Detects: site down, slow responses, SSL errors. Alerts within 1-2 minutes. Essential‚Äîcan't rely on customers to tell you." },
            { q: "You have 100 JavaScript errors per hour. Is this a problem?", opts: ["Yes‚Äîall errors are bad", "Depends on traffic. 100 errors/hour with 10k users = 1% error rate (high, investigate). 100 errors/hour with 1M users = 0.01% error rate (acceptable). Track error RATE, not absolute count.", "No‚Äîsome errors are normal", "Need more information about error types"], correct: 1, explain: "Absolute error count is meaningless without context. Track error RATE (errors/requests). 0.01% error rate might be acceptable (edge cases). 1%+ error rate is high‚Äîmany users affected. Also track: is rate increasing?" },
            { q: "How do you prevent alert fatigue (team ignores alerts)?", opts: ["Send more alerts to emphasize importance", "Alert only on actionable issues. Use levels: CRITICAL (immediate action), WARNING (investigate), INFO (track trends). Suppress during maintenance. Group related alerts. If team ignores alerts, you're alerting too much or on wrong things.", "Rotate who gets alerts", "Reduce all alerts"], correct: 1, explain: "Alert fatigue happens when too many non-actionable alerts train team to ignore them. Fix: 1) Critical alerts only for urgent issues, 2) Warnings for investigation, 3) Info for trends, 4) Suppress known maintenance, 5) Group related alerts. Every alert should require action." },
            { q: "Your monitoring shows checkout completion dropped from 78% to 65%. What do you check first?", opts: ["Blame marketing for bad traffic", "Correlate with technical metrics: Did p95 response time spike? Error rate increase? Recent deploy? Payment API issues? Check timeline: when did drop start? Checkout slowness often causes abandonment.", "Wait to see if it recovers", "Run A/B test"], correct: 1, explain: "Sudden checkout drops often have technical causes. Check: 1) Response times (slow checkout = abandonment), 2) Error rates (JS errors breaking checkout), 3) Recent deploys (new bugs), 4) Third-party APIs (Stripe down). Correlate technical and business metrics." }
        ],
        essay: { q: "You're the COO of an ecommerce company doing ¬£1M/month revenue. Currently you find out about site issues from customer complaints. Design a monitoring strategy. What tools? What metrics? What alerts? What's the cost vs risk?", guide: "Current risk: 30-60 min MTTR (mean time to resolution) because detection is slow. ¬£1M/mo = ¬£1.4k/hour. One hour of downtime per month = ¬£16.8k/year lost. Monitoring strategy: 1) Uptime: Pingdom ($20/mo) - checks every 60 seconds, alerts within 2 min. 2) Errors: Sentry ($80/mo) - catches all JS/backend errors with stack traces. 3) Performance: New Relic or Datadog ($200/mo) - tracks p95 latency, identifies slow endpoints. 4) Business: Google Analytics (free) - tracks checkout completion, revenue/hour. 5) Alerts: Critical (SMS): site down, payment failing. Warning (Slack): error rate > 1%, p95 > 1000ms, checkout < 70%. Total cost: $300/month = ¬£3.6k/year. ROI: Prevents even ONE hour of undetected downtime/year (¬£16.8k) = 4.6x return. Reduces MTTR from 30min to 5min = 83% improvement. Implementation: Week 1: Pingdom + Sentry ($100/mo minimum viable). Week 2-3: Add APM and correlate with business metrics. Week 4: Tune alerts, create dashboards, document runbooks." }
    },
    // DAY 24 - SECURITY BEST PRACTICES
    {
        day: 24,
        week: 3,
        title: "Security Best Practices",
        desc: "OWASP Top 10, XSS, CSRF, SQL injection",
        duration: "55 min",
        coldOpen: "Security audit found 15 vulnerabilities: SQL injection, XSS, exposed API keys, weak passwords, no rate limiting. Budget for fixes: ¬£30k. How do you prioritize? What's the actual risk?",
        coldRevisit: "Prioritize by OWASP Top 10 severity + exploitation likelihood + business impact. Critical (fix immediately): SQL injection, broken authentication, XSS. High: rate limiting, password policy. Medium: dependency updates. Calculate: breach cost vs fix cost.",
        content: "<h2>Why This Matters</h2><p>Security breaches cost UK companies average ¬£3.2M. GDPR fines reach ¬£17M. One SQL injection can expose entire database. Understanding security helps you prioritize fixes and avoid expensive breaches.</p><h2>1. OWASP Top 10 (2021)</h2><table><tr><th>Rank</th><th>Vulnerability</th><th>Example</th></tr><tr><td>1</td><td>Broken Access Control</td><td>Change URL /orders/123 ‚Üí /orders/456 to see others' orders</td></tr><tr><td>2</td><td>Cryptographic Failures</td><td>Passwords in plain text, no HTTPS</td></tr><tr><td>3</td><td>Injection (SQL, XSS)</td><td>Search: ' OR '1'='1 exposes all data</td></tr><tr><td>4</td><td>Insecure Design</td><td>No rate limiting allows brute-force</td></tr><tr><td>5</td><td>Security Misconfiguration</td><td>Default admin password, debug in production</td></tr></table><h2>2. SQL Injection</h2><pre>// VULNERABLE\nconst query = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n// Input: ' OR '1'='1\n// Returns ALL users!\n\n// SECURE (parameterized)\nconst query = 'SELECT * FROM users WHERE email = ?';\ndb.query(query, [email]);</pre><p><strong>Impact:</strong> Database fully exposed, GDPR violation, ¬£17M fine potential.</p><h2>3. Cross-Site Scripting (XSS)</h2><pre>// VULNERABLE\nres.send(`<h1>Search: ${query}</h1>`);\n// URL: /search?q=<script>steal_cookies()</script>\n\n// SECURE\nconst escape = require('escape-html');\nres.send(`<h1>Search: ${escape(query)}</h1>`);</pre><p><strong>Impact:</strong> Session hijacking, user impersonation</p><h2>4. Authentication Security</h2><pre>// Password hashing\nconst bcrypt = require('bcrypt');\nconst hash = await bcrypt.hash(password, 10);\n\n// Session security\napp.use(session({\n  cookie: {\n    httpOnly: true,   // XSS protection\n    secure: true,     // HTTPS only\n    sameSite: 'strict' // CSRF protection\n  }\n}));</pre><h2>5. Rate Limiting</h2><pre>const rateLimit = require('express-rate-limit');\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,  // 5 attempts per 15 minutes\n  message: 'Too many attempts'\n});\napp.post('/login', loginLimiter, handler);</pre><p>Without rate limiting: 1000 passwords/second = 86k/day. With: 480/day (brute force impractical).</p><h2>6. Security Checklist</h2><table><tr><th>Priority</th><th>Control</th><th>Cost</th></tr><tr><td>CRITICAL</td><td>Parameterized queries</td><td>1-2 days</td></tr><tr><td>CRITICAL</td><td>HTTPS everywhere</td><td>¬£50/yr + 2 hours</td></tr><tr><td>CRITICAL</td><td>Hash passwords (bcrypt)</td><td>1 day</td></tr><tr><td>HIGH</td><td>Escape user input</td><td>2-3 days</td></tr><tr><td>HIGH</td><td>CSRF protection</td><td>1 day</td></tr><tr><td>HIGH</td><td>Rate limiting</td><td>4 hours</td></tr><tr><td>MEDIUM</td><td>Dependency updates</td><td>Ongoing</td></tr></table><h2>7. Breach Cost vs Prevention</h2><pre>Breach cost:\n- GDPR fine: ¬£40k-17M\n- Legal fees: ¬£200k-2M\n- Reputation: 20-30% revenue loss\n- Total: ¬£1M-10M\n\nPrevention cost:\n- Fixes: ¬£10k-30k\n- Audit: ¬£5k-15k\n- Tools: ¬£2k-10k/yr\n- Total: ¬£25k-83k\n\nROI: 10-100x</pre>",
        questions: [
            { q: "SQL injection found. CFO asks 'how bad?' What do you say?", opts: ["Just a code bug", "CRITICAL. Can expose entire database: customer PII, payments. GDPR breach = ¬£17M fine + lawsuits. Equifax cost: $4B. Fix immediately (1-2 days with parameterized queries).", "Fix when convenient", "Only bad if exploited"], correct: 1, explain: "SQL injection is CRITICAL. Full database access possible. One vulnerability = catastrophic breach. Equifax: $4B cost from SQL injection. Fix immediately." },
            { q: "Login has no rate limiting. Why is this risky?", opts: ["Not risky", "Enables brute-force: 1000 passwords/second = 86k/day. Common passwords cracked fast. Rate limiting (5/15min) reduces to 480/day, making brute force impractical.", "Users login too fast", "Database overload"], correct: 1, explain: "Without rate limiting, brute force is practical: 86k attempts/day. Rate limiting (5/15min) = 480/day, impractical for brute force. Critical for auth endpoints." },
            { q: "Passwords hashed with MD5. Security says 'inadequate'. Why?", opts: ["MD5 is fine", "MD5 too fast‚Äîbillions cracked/second with GPUs. bcrypt intentionally slow (tunable), resists brute-force. Always use bcrypt/scrypt/argon2, never MD5/SHA.", "MD5 just old", "Don't need hashing"], correct: 1, explain: "MD5/SHA designed for speed. Attackers crack billions/second. bcrypt intentionally slow, adjustable difficulty. Password hashing must be slow. Use bcrypt/scrypt/argon2." },
            { q: "ROI of ¬£50k security fixes vs doing nothing?", opts: ["¬£50k wasted", "Average breach: ¬£1M-10M. Prevention: ¬£50k. Break-even: prevent one breach every 20-200 years. Given exploitation likelihood, ROI is 10-100x.", "Can't calculate ROI", "Calculate after breach"], correct: 1, explain: "Breach: ¬£1M-10M. Prevention: ¬£25k-83k. Expected loss calculation shows 10-100x ROI. Plus GDPR compliance, customer trust, reduced insurance premiums." },
            { q: "15 vulnerabilities found. How to prioritize?", opts: ["Fix all equally", "OWASP severity + exploit likelihood + business impact. Critical (SQL, XSS) = immediate. High (CSRF, rate limit) = 2 weeks. Medium (dependencies) = quarter. Group similar fixes.", "Cheapest first", "Random order"], correct: 1, explain: "Prioritization: 1) Severity (OWASP ranking), 2) Exploitation likelihood, 3) Business impact (customer PII = critical), 4) Cost/effort. Do critical fixes first, quick wins early." }
        ],
        essay: { q: "Security audit found 15 vulnerabilities. How do you prioritize with ¬£30k budget? Framework?", guide: "Framework: 1) Severity (OWASP): Critical (SQL injection, XSS) = immediate. High (CSRF, rate limit) = 2 weeks. Medium (dependencies) = quarter. 2) Exploit likelihood: Public exploits = higher priority. 3) Business impact: Customer PII = critical (GDPR). 4) Cost: Quick wins first (rate limiting = 4 hours). Example: SQL injection (1 day), XSS 3 places (2 days), rate limiting (4 hours), weak passwords (1 day), HTTPS staging (2 hours), error messages (1 day), dependencies (ongoing). Total: 6 days = ¬£10k. Critical fixes done, prevents ¬£1M-10M breach. Present to CFO: ¬£10k vs ¬£1M+ risk = 100x ROI." }
    },
    // DAY 25 - CI/CD & DEPLOYMENT
    { day: 25, week: 3, title: "CI/CD & Deployment", desc: "Automated testing and deployment", duration: "50 min",
      coldOpen: "Deployment takes 3 hours, manual. Can this be automated?",
      coldRevisit: "Yes. CI/CD automates: test, build, deploy. Deploys become safe, frequent, fast (minutes not hours).",
      content: "<h2>CI/CD Pipeline</h2><pre>1. Code commit\\n2. Automated tests run\\n3. Build production bundle\\n4. Deploy to staging\\n5. Deploy to production</pre><h2>Benefits</h2><ul><li>Fast: Minutes not hours</li><li>Safe: Tests catch bugs</li><li>Frequent: Deploy multiple times/day</li></ul>",
      questions: [
        { q: "What's CI/CD?", opts: ["Cloud hosting", "Continuous Integration/Deployment. Automate testing and deployment.", "Database tool", "Monitoring"], correct: 1, explain: "CI/CD = automated pipeline from code commit to production deploy." }
      ],
      essay: { q: "Current deployment: 3 hours, manual, error-prone. Design CI/CD.", guide: "GitHub Actions: run tests, build, deploy staging, manual approval, deploy prod. 10-15 min total." }
    },
    // DAY 26 - INCIDENT MANAGEMENT
    { day: 26, week: 3, title: "Incident Management", desc: "Responding to outages", duration: "50 min",
      coldOpen: "Site is down. Now what?",
      coldRevisit: "1) Assess impact, 2) Communicate, 3) Mitigate, 4) Fix root cause, 5) Postmortem.",
      content: "<h2>Incident Response</h2><ol><li>Assess: What's broken? Impact?</li><li>Communicate: Status page, team alert</li><li>Mitigate: Quick fix to restore service</li><li>Root cause: Fix properly</li><li>Postmortem: What happened? Prevent recurrence</li></ol>",
      questions: [
        { q: "Site down. First step?", opts: ["Find culprit", "Assess impact: How many users affected? Is it full outage or partial?", "Roll back", "Call CEO"], correct: 1, explain: "First: understand scope and impact. Drives response urgency." }
      ],
      essay: { q: "Database crashed. Site down 2 hours. Create postmortem.", guide: "What happened? Why? Impact? Timeline? Action items to prevent recurrence? Blameless." }
    },
    // DAY 27 - CLOUD COST OPTIMIZATION
    { day: 27, week: 3, title: "Cloud Cost Optimization", desc: "Managing infrastructure spend", duration: "50 min",
      coldOpen: "Cloud costs up 50%. Where's the money going?",
      coldRevisit: "Check: over-provisioned servers, unused resources, inefficient queries, no auto-scaling, development environments running 24/7.",
      content: "<h2>Cost Culprits</h2><ul><li>Over-provisioned: Server too powerful</li><li>Always-on dev/staging</li><li>No auto-scaling</li><li>Unused databases</li><li>Expensive data transfer</li></ul><h2>Quick Wins</h2><p>Shut down non-prod at night. Rightsize instances. Use reserved/spot instances.</p>",
      questions: [
        { q: "Cloud costs doubled. First check?", opts: ["Switch providers", "Audit: What resources exist? What's actually used? Are dev/staging running 24/7?", "Optimize code", "Reduce features"], correct: 1, explain: "Audit first. Often: unused resources, over-provisioned instances, always-on non-prod." }
      ],
      essay: { q: "AWS bill up 50% (¬£10k‚Üí¬£15k/month). Investigate and optimize.", guide: "Tag resources. Find: unused databases, oversized EC2, 24/7 dev. Shut down non-prod off-hours. Rightsize. Reserved instances." }
    },
    // DAY 28 - WEEK 3 REVIEW
    { day: 28, week: 3, title: "Week 3 Review", desc: "Operations & Security", duration: "45 min",
      coldOpen: "Board asks: How healthy is our tech?",
      coldRevisit: "Present: uptime, deployment frequency, incident count, security posture, cost trends.",
      content: "<h2>Week 3 Takeaways</h2><ul><li>Architecture: Start simple, add complexity only when needed</li><li>Monitoring: Proactive beats reactive</li><li>Security: OWASP Top 10, fix critical first</li><li>CI/CD: Automate deploys</li><li>Incidents: Have process, practice</li><li>Costs: Monitor, optimize</li></ul>",
      questions: [
        { q: "Measure tech health?", opts: ["Code quality", "DORA metrics: deploy frequency, lead time, MTTR, change failure rate. Plus: uptime, costs.", "Lines of code", "Team size"], correct: 1, explain: "DORA metrics measure delivery performance. Combined with uptime and costs = tech health." }
      ],
      essay: { q: "Create quarterly tech health report for board.", guide: "Metrics: uptime, deploy frequency, incidents, security issues fixed, cost trends. Narrative: progress, risks, investments needed." }
    },
    // DAY 29 - TECHNICAL LEADERSHIP
    { day: 29, week: 4, title: "Technical Leadership", desc: "Managing engineers effectively", duration: "50 min",
      coldOpen: "Engineering says 6 months, product says 6 weeks. How to navigate?",
      coldRevisit: "Understand constraints. Break down estimate. Find MVP. Engineering estimates are often correct‚Äîunderstand why before pressuring.",
      content: "<h2>Bridging Engineering & Business</h2><p>Engineers estimate full solution. Business needs MVP. Find middle ground: what's must-have vs nice-to-have?</p><h2>Questions to Ask</h2><ul><li>What's included in 6 months?</li><li>What's minimum viable?</li><li>What's highest risk/unknown?</li><li>Can we phase it?</li></ul>",
      questions: [
        { q: "Engineer says 6 months. Product wants 6 weeks. Response?", opts: ["Pressure engineer", "Understand estimate: What's included? Can we scope down to MVP? What's risky? Don't just pressure‚Äîunderstand constraints.", "Hire more", "Fire engineer"], correct: 1, explain: "Understand before pressuring. Often: engineer is right, or there's MVP that meets need faster." }
      ],
      essay: { q: "Navigate 6-month estimate vs 6-week business need.", guide: "Break down estimate. Identify: must-have, nice-to-have, risky parts. Find 6-week MVP. Phase remaining. Don't just cut time‚Äîcut scope." }
    },
    // DAY 30 - TECHNICAL ROADMAPPING
    { day: 30, week: 4, title: "Technical Roadmapping", desc: "Aligning tech with business", duration: "50 min",
      coldOpen: "CEO wants 3-year tech roadmap. How to create?",
      coldRevisit: "Start with business strategy. What are business goals? Map tech investments to enable them. Balance: new features, tech debt, infrastructure.",
      content: "<h2>Roadmap Framework</h2><ol><li>Business goals (next 3 years)</li><li>Tech capabilities needed</li><li>Current state gaps</li><li>Prioritized investments</li></ol><h2>Balance</h2><p>70% business features, 20% tech debt, 10% experimentation.</p>",
      questions: [
        { q: "How to prioritize tech roadmap?", opts: ["Newest tech", "Align with business goals. What tech investments enable revenue/growth/efficiency? Balance features, debt, infra.", "Cheapest first", "Random"], correct: 1, explain: "Tech roadmap serves business goals. Every investment should map to business outcome." }
      ],
      essay: { q: "CEO wants to expand to 10 new countries. Create tech roadmap.", guide: "Needs: i18n, multi-currency, regional hosting/CDN, compliance (GDPR, etc). Phase: highest-revenue countries first. Estimate costs, timeline." }
    }
];

// Export for use in main app
if (typeof module !== 'undefined' && module.exports) {
    module.exports = lessonsData;
}
